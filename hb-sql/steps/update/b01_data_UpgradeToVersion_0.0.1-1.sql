/*
Deployment script for MultiCodeBoard

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar gitBaseFolder "."
:setvar relativePath "$(relativePath)"
:setvar DatabaseName "MultiCodeBoard"
:setvar DefaultFilePrefix "MultiCodeBoard"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQL2012EXPRESS\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQL2012EXPRESS\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
The column [dbo].[BillboardLog].[CummulativeAchieved] is being dropped, data loss could occur.

The column [dbo].[BillboardLog].[CummulativeTarget] is being dropped, data loss could occur.

The column [dbo].[BillboardLog].[UpdateUserID] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [dbo].[BillboardLog])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [dbo].[ShiftLog].[LocationID] on table [dbo].[ShiftLog] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [dbo].[ShiftLog])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [dbo].[ShiftLogBreak].[UpdateDate] on table [dbo].[ShiftLogBreak] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.

The type for column TimeEnd in table [dbo].[ShiftLogBreak] is currently  TIME (7) NOT NULL but is being changed to  DATETIME NOT NULL. Data loss could occur.

The type for column TimeStart in table [dbo].[ShiftLogBreak] is currently  TIME (7) NOT NULL but is being changed to  DATETIME NOT NULL. Data loss could occur.
*/

IF EXISTS (select top 1 1 from [dbo].[ShiftLogBreak])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [dbo].[ShiftLogSignOff].[UpdateUserID] is being dropped, data loss could occur.

The column [dbo].[ShiftLogSignOff].[LineID] on table [dbo].[ShiftLogSignOff] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [dbo].[ShiftLogSignOff])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [target].[Daily].[TypeID] on table [target].[Daily] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [target].[Daily])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [target].[Hourly].[CumulativeValue] on table [target].[Hourly] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [target].[Hourly])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [production].[Cell] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [production].[Cell])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [production].[Line] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [production].[Line])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [production].[Item] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [production].[Item])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [production].[Workbench] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [production].[Workbench])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [dbo].[User] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [dbo].[User])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [dbo].[UserRole] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [dbo].[UserRole])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [target].[Item] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [target].[Item])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [target].[ItemShift] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [target].[ItemShift])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Rename refactoring operation with key fdcef213-7beb-4f63-9529-746e034916ba is skipped, element [dbo].[Error].[IsObsolete] (SqlSimpleColumn) will not be renamed to Deleted';


GO
PRINT N'Rename refactoring operation with key b803893f-8d4f-4392-b255-94f5ad210f1e is skipped, element [layout].[Repository].[IsObsolete] (SqlSimpleColumn) will not be renamed to Deleted';


GO
PRINT N'Rename refactoring operation with key 2f06326a-6a06-4b44-bd8d-84547265c764 is skipped, element [layout].[Repository].[TypeId] (SqlSimpleColumn) will not be renamed to TypeID';


GO
PRINT N'Rename refactoring operation with key f8549984-7448-4c1a-9f34-bcea9bde9f52 is skipped, element [layout].[WorkbenchType].[RepositoryId] (SqlSimpleColumn) will not be renamed to RepositoryID';


GO
PRINT N'Rename refactoring operation with key f8e69081-3f87-4af6-869b-097f8498140c is skipped, element [log].[ProcedureLog].[ProcedureId] (SqlSimpleColumn) will not be renamed to ProcedureID';


GO
PRINT N'Rename refactoring operation with key 5d344392-6d88-4988-aa67-baa37f2cfd74 is skipped, element [log].[ProcedureLog].[ProfileId] (SqlSimpleColumn) will not be renamed to ProfileID';


GO
PRINT N'The following operation was generated from a refactoring log file fa52108b-8784-44a6-91fa-1d8db626bcff';

PRINT N'Rename [target].[Item].[ItemID] to PartNumberID';


GO
EXECUTE sp_rename @objname = N'[target].[Item].[ItemID]', @newname = N'PartNumberID', @objtype = N'COLUMN';


GO
PRINT N'Rename refactoring operation with key 02f784a5-d5bb-45f3-b23d-a811755a1876 is skipped, element [users].[Operator].[IsObsolete] (SqlSimpleColumn) will not be renamed to Deleted';


GO
PRINT N'Rename refactoring operation with key 59c438e2-452e-4014-aaa5-367225c127fa is skipped, element [users].[Account].[createdAt] (SqlSimpleColumn) will not be renamed to CreatedAt';


GO
PRINT N'Rename refactoring operation with key db1c78cc-7140-445e-80b8-fb3d92d71bae is skipped, element [users].[Account].[updatedAt] (SqlSimpleColumn) will not be renamed to UpdatedAt';


GO
PRINT N'Rename refactoring operation with key 28f80f4a-92ea-45ab-bd4e-d98659745fd4 is skipped, element [users].[Account].[Deleted] (SqlSimpleColumn) will not be renamed to Deleted';


GO
PRINT N'Rename refactoring operation with key c8c91fab-e57d-4eab-8211-c7d39d31bf8e is skipped, element [users].[AccountLoginHistory].[id] (SqlSimpleColumn) will not be renamed to ID';


GO
PRINT N'Rename refactoring operation with key 3684f4bd-2f96-4956-9533-aa0f34ae46db is skipped, element [users].[Profile].[Deleted] (SqlSimpleColumn) will not be renamed to Deleted';


GO
PRINT N'Rename refactoring operation with key 26839b28-9d21-4538-af37-cf12b1df3492 is skipped, element [users].[Profile].[createdAt] (SqlSimpleColumn) will not be renamed to CreatedAt';


GO
PRINT N'Rename refactoring operation with key e2e3cab2-7b76-429a-8884-6f0be08c1da7 is skipped, element [users].[Profile].[updatedAt] (SqlSimpleColumn) will not be renamed to UpdatedAt';


GO
PRINT N'Rename refactoring operation with key a93dc6ed-315a-4b6f-868e-c1e4755d8021 is skipped, element [users].[Profile_] (SqlDmlTrigger) will not be renamed to [Profile_CheckUniqueOperator_InsertUpdate]';


GO
PRINT N'Rename refactoring operation with key c15e2aaf-3ee8-4db1-9e00-94a96f168a8d is skipped, element [dbo].[OperationLog].[Id] (SqlSimpleColumn) will not be renamed to ID';


GO
PRINT N'Rename refactoring operation with key 5ef0b351-d59a-49ff-9373-424b394fb1ff is skipped, element [dbo].[Trigger_ShiftLogBreak] (SqlDmlTrigger) will not be renamed to [ShiftLogBreak_CheckTimeBetweenShiftLimits]';


GO
PRINT N'Rename refactoring operation with key ee8dfff2-2b20-4f8b-9ef1-0f01f07e4d18, fcd902dd-66b4-491a-9094-4d8f11320539 is skipped, element [layout].[Monitor].[PhysicalLocation] (SqlSimpleColumn) will not be renamed to Location';


GO
PRINT N'Rename refactoring operation with key c756332c-f9a4-478a-a293-ded51bad7a92 is skipped, element [layout].[Line].[Timeout] (SqlSimpleColumn) will not be renamed to TimeOut';


GO
PRINT N'Rename refactoring operation with key c4d57ce9-ee6b-493c-8cce-1fdbf0d3fde3 is skipped, element [layout].[Workbench].[Timeout] (SqlSimpleColumn) will not be renamed to TimeOut';


GO
PRINT N'Rename refactoring operation with key b518fead-f14f-41bc-9eb2-ba5f355306f2 is skipped, element [layout].[Cell].[Timeout] (SqlSimpleColumn) will not be renamed to TimeOut';


GO
PRINT N'The following operation was generated from a refactoring log file d60d038c-2b1a-4d5d-bb92-b5d60ed61b98';

PRINT N'Rename [dbo].[BillboardLog].[SignedOff] to SignedOffOperatorID';


GO
EXECUTE sp_rename @objname = N'[dbo].[BillboardLog].[SignedOff]', @newname = N'SignedOffOperatorID', @objtype = N'COLUMN';


GO
PRINT N'The following operation was generated from a refactoring log file d5152b98-9a7a-4c98-b086-b35d4cba3ba6';

PRINT N'Rename [dbo].[ShiftLogSignOff].[SignedOff] to SignedOffOperatorID';


GO
EXECUTE sp_rename @objname = N'[dbo].[ShiftLogSignOff].[SignedOff]', @newname = N'SignedOffOperatorID', @objtype = N'COLUMN';


GO
PRINT N'Rename refactoring operation with key 4e15e997-3aa5-4cf6-a3ff-d918d7c47707 is skipped, element [dbo].[LineTag].[Id] (SqlSimpleColumn) will not be renamed to LineID';


GO
PRINT N'Rename refactoring operation with key b48a64cd-6751-4ceb-9fa1-a739489f0407 is skipped, element [layout].[LineTag_] (SqlDmlTrigger) will not be renamed to [LineTag_GenerateTags_InsertUpdateDelete]';


GO
PRINT N'Dropping [dbo].[DF_BillboardLog_SignedOff]...';


GO
ALTER TABLE [dbo].[BillboardLog] DROP CONSTRAINT [DF_BillboardLog_SignedOff];


GO
PRINT N'Dropping [dbo].[DF_ShiftLogSignOff_SignedOff]...';


GO
ALTER TABLE [dbo].[ShiftLogSignOff] DROP CONSTRAINT [DF_ShiftLogSignOff_SignedOff];


GO
PRINT N'Dropping [dbo].[DF_ShiftLogSignOff_Automatic]...';


GO
ALTER TABLE [dbo].[ShiftLogSignOff] DROP CONSTRAINT [DF_ShiftLogSignOff_Automatic];


GO
PRINT N'Dropping [dbo].[FK_Billboard_TargetHourly]...';


GO
ALTER TABLE [dbo].[BillboardLog] DROP CONSTRAINT [FK_Billboard_TargetHourly];


GO
PRINT N'Dropping [dbo].[FK_Billboard_UpdateUser]...';


GO
ALTER TABLE [dbo].[BillboardLog] DROP CONSTRAINT [FK_Billboard_UpdateUser];


GO
PRINT N'Dropping [dbo].[FK_ShiftLogSignOff_ShiftLog]...';


GO
ALTER TABLE [dbo].[ShiftLogSignOff] DROP CONSTRAINT [FK_ShiftLogSignOff_ShiftLog];


GO
PRINT N'Dropping [dbo].[FK_ShiftLog_PreviousShiftLog]...';


GO
ALTER TABLE [dbo].[ShiftLog] DROP CONSTRAINT [FK_ShiftLog_PreviousShiftLog];


GO
PRINT N'Dropping [dbo].[FK_ShiftLogBreak_ShiftLog]...';


GO
ALTER TABLE [dbo].[ShiftLogBreak] DROP CONSTRAINT [FK_ShiftLogBreak_ShiftLog];


GO
PRINT N'Dropping [target].[FK_TargetDaily_ShiftLog]...';


GO
ALTER TABLE [target].[Daily] DROP CONSTRAINT [FK_TargetDaily_ShiftLog];


GO
PRINT N'Dropping [target].[FK_TargetItemShift_ShiftLog]...';


GO
ALTER TABLE [target].[ItemShift] DROP CONSTRAINT [FK_TargetItemShift_ShiftLog];


GO
PRINT N'Dropping [dbo].[FK_ShiftLogSignOff_UpdateUser]...';


GO
ALTER TABLE [dbo].[ShiftLogSignOff] DROP CONSTRAINT [FK_ShiftLogSignOff_UpdateUser];


GO
PRINT N'Dropping [target].[FK_TargetDaily_ProductionLine]...';


GO
ALTER TABLE [target].[Daily] DROP CONSTRAINT [FK_TargetDaily_ProductionLine];


GO
PRINT N'Dropping [target].[FK_TargetHourly_TargetDaily]...';


GO
ALTER TABLE [target].[Hourly] DROP CONSTRAINT [FK_TargetHourly_TargetDaily];


GO
PRINT N'Dropping [target].[FK_TargetHourly_UpdateUser]...';


GO
ALTER TABLE [target].[Hourly] DROP CONSTRAINT [FK_TargetHourly_UpdateUser];


GO
PRINT N'Dropping [production].[FK_ProductionWorkbench_ProductionCell]...';


GO
ALTER TABLE [production].[Workbench] DROP CONSTRAINT [FK_ProductionWorkbench_ProductionCell];


GO
PRINT N'Dropping [production].[FK_ProductionCell_ProductionLine]...';


GO
ALTER TABLE [production].[Cell] DROP CONSTRAINT [FK_ProductionCell_ProductionLine];


GO
PRINT N'Dropping [target].[FK_TargetItem_ProductionItem]...';


GO
ALTER TABLE [target].[Item] DROP CONSTRAINT [FK_TargetItem_ProductionItem];


GO
PRINT N'Dropping [production].[FK_ProductionWorkbench_ProductionPreviousWorkbench]...';


GO
ALTER TABLE [production].[Workbench] DROP CONSTRAINT [FK_ProductionWorkbench_ProductionPreviousWorkbench];


GO
PRINT N'Dropping [target].[FK_TargetShift_UpdateUser]...';


GO
ALTER TABLE [target].[Item] DROP CONSTRAINT [FK_TargetShift_UpdateUser];


GO
PRINT N'Dropping [target].[FK_TargetItemShift_UpdateUser]...';


GO
ALTER TABLE [target].[ItemShift] DROP CONSTRAINT [FK_TargetItemShift_UpdateUser];


GO
PRINT N'Dropping [dbo].[FK_User_UserRole]...';


GO
ALTER TABLE [dbo].[User] DROP CONSTRAINT [FK_User_UserRole];


GO
PRINT N'Dropping [dbo].[CK_BillboardLog_CummulativeAchieved]...';


GO
ALTER TABLE [dbo].[BillboardLog] DROP CONSTRAINT [CK_BillboardLog_CummulativeAchieved];


GO
PRINT N'Dropping [target].[CK_TargetItem_Value]...';


GO
ALTER TABLE [target].[Item] DROP CONSTRAINT [CK_TargetItem_Value];


GO
PRINT N'Dropping [target].[CK_TargetItemShift_Value]...';


GO
ALTER TABLE [target].[ItemShift] DROP CONSTRAINT [CK_TargetItemShift_Value];


GO
PRINT N'Dropping [production].[Cell]...';


GO
DROP TABLE [production].[Cell];


GO
PRINT N'Dropping [production].[Line]...';


GO
DROP TABLE [production].[Line];


GO
PRINT N'Dropping [production].[Item]...';


GO
DROP TABLE [production].[Item];


GO
PRINT N'Dropping [production].[Workbench]...';


GO
DROP TABLE [production].[Workbench];


GO
PRINT N'Dropping [dbo].[User]...';


GO
DROP TABLE [dbo].[User];


GO
PRINT N'Dropping [dbo].[UserRole]...';


GO
DROP TABLE [dbo].[UserRole];


GO
PRINT N'Dropping [target].[Item]...';


GO
DROP TABLE [target].[Item];


GO
PRINT N'Dropping [target].[ItemShift]...';


GO
DROP TABLE [target].[ItemShift];


GO
PRINT N'Dropping [dbo].[fsGetDate]...';


GO
DROP FUNCTION [dbo].[fsGetDate];


GO
PRINT N'Dropping [production]...';


GO
DROP SCHEMA [production];


GO
PRINT N'Creating [global]...';


GO
CREATE SCHEMA [global]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [layout]...';


GO
CREATE SCHEMA [layout]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [log]...';


GO
CREATE SCHEMA [log]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [report]...';


GO
CREATE SCHEMA [report]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [users]...';


GO
CREATE SCHEMA [users]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dbo].[idTable]...';


GO
CREATE TYPE [dbo].[idTable] AS TABLE (
    [ID] INT NOT NULL);


GO
PRINT N'Starting rebuilding table [dbo].[ShiftLog]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_ShiftLog] (
    [ID]                 INT      IDENTITY (1, 1) NOT NULL,
    [LocationID]         CHAR (2) NOT NULL,
    [ShiftType]          CHAR (1) NOT NULL,
    [Data]               DATETIME NOT NULL,
    [DataStart]          DATETIME NOT NULL,
    [PreviousShiftLogID] INT      NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ShiftLog1] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [tmp_ms_xx_constraint_IX_ShiftLog_ShiftData1] UNIQUE NONCLUSTERED ([ShiftType] ASC, [Data] ASC) WITH (FILLFACTOR = 90)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[ShiftLog])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_ShiftLog] ON;
        INSERT INTO [dbo].[tmp_ms_xx_ShiftLog] ([ID], [ShiftType], [Data], [DataStart], [PreviousShiftLogID])
        SELECT   [ID],
                 [ShiftType],
                 [Data],
                 [DataStart],
                 [PreviousShiftLogID]
        FROM     [dbo].[ShiftLog]
        ORDER BY [ID] ASC;
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_ShiftLog] OFF;
    END

DROP TABLE [dbo].[ShiftLog];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_ShiftLog]', N'ShiftLog';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PK_ShiftLog1]', N'PK_ShiftLog', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_IX_ShiftLog_ShiftData1]', N'IX_ShiftLog_ShiftData', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [dbo].[ShiftLogBreak]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_ShiftLogBreak] (
    [ShiftLogID] INT      NOT NULL,
    [TimeStart]  DATETIME NOT NULL,
    [TimeEnd]    DATETIME NOT NULL,
    [UpdateDate] DATETIME NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ShiftLogBreak1] PRIMARY KEY CLUSTERED ([ShiftLogID] ASC, [TimeStart] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[ShiftLogBreak])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_ShiftLogBreak] ([ShiftLogID], [TimeStart], [TimeEnd])
        SELECT   [ShiftLogID],
                 [TimeStart],
                 [TimeEnd]
        FROM     [dbo].[ShiftLogBreak]
        ORDER BY [ShiftLogID] ASC, [TimeStart] ASC;
    END

DROP TABLE [dbo].[ShiftLogBreak];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_ShiftLogBreak]', N'ShiftLogBreak';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PK_ShiftLogBreak1]', N'PK_ShiftLogBreak', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [dbo].[ShiftLogSignOff]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_ShiftLogSignOff] (
    [ID]                  INT      IDENTITY (1, 1) NOT NULL,
    [ShiftLogID]          INT      NOT NULL,
    [LineID]              SMALLINT NOT NULL,
    [SignedOffOperatorID] INT      NULL,
    [Automatic]           BIT      CONSTRAINT [DF_ShiftLogSignOff_Automatic] DEFAULT ((0)) NOT NULL,
    [UpdateDate]          DATETIME NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ShiftLogSignOff1] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [tmp_ms_xx_constraint_IX_ShiftLogSignOff1] UNIQUE NONCLUSTERED ([LineID] ASC, [ShiftLogID] ASC) WITH (FILLFACTOR = 90)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[ShiftLogSignOff])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_ShiftLogSignOff] ([ShiftLogID], [SignedOffOperatorID], [Automatic], [UpdateDate])
        SELECT [ShiftLogID],
               [SignedOffOperatorID],
               [Automatic],
               [UpdateDate]
        FROM   [dbo].[ShiftLogSignOff];
    END

DROP TABLE [dbo].[ShiftLogSignOff];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_ShiftLogSignOff]', N'ShiftLogSignOff';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PK_ShiftLogSignOff1]', N'PK_ShiftLogSignOff', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_IX_ShiftLogSignOff1]', N'IX_ShiftLogSignOff', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [target].[Daily]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [target].[tmp_ms_xx_Daily] (
    [ID]           INT      IDENTITY (1, 1) NOT NULL,
    [TypeID]       CHAR (2) NOT NULL,
    [LineID]       SMALLINT NOT NULL,
    [ShiftLogID]   INT      NOT NULL,
    [Value]        SMALLINT NOT NULL,
    [Billboard]    BIT      CONSTRAINT [DF_TargetDaily_Billboard] DEFAULT 0 NOT NULL,
    [UpdateUserID] INT      NOT NULL,
    [UpdateDate]   DATETIME NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_TargetDaily1] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [tmp_ms_xx_constraint_IX_Daily1] UNIQUE NONCLUSTERED ([TypeID] ASC, [LineID] ASC, [ShiftLogID] ASC) WITH (FILLFACTOR = 90)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [target].[Daily])
    BEGIN
        SET IDENTITY_INSERT [target].[tmp_ms_xx_Daily] ON;
        INSERT INTO [target].[tmp_ms_xx_Daily] ([ID], [LineID], [ShiftLogID], [Value], [UpdateUserID], [UpdateDate])
        SELECT   [ID],
                 [LineID],
                 [ShiftLogID],
                 [Value],
                 [UpdateUserID],
                 [UpdateDate]
        FROM     [target].[Daily]
        ORDER BY [ID] ASC;
        SET IDENTITY_INSERT [target].[tmp_ms_xx_Daily] OFF;
    END

DROP TABLE [target].[Daily];

EXECUTE sp_rename N'[target].[tmp_ms_xx_Daily]', N'Daily';

EXECUTE sp_rename N'[target].[tmp_ms_xx_constraint_PK_TargetDaily1]', N'PK_TargetDaily', N'OBJECT';

EXECUTE sp_rename N'[target].[tmp_ms_xx_constraint_IX_Daily1]', N'IX_Daily', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [target].[Hourly]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [target].[tmp_ms_xx_Hourly] (
    [ID]              INT      IDENTITY (1, 1) NOT NULL,
    [DailyID]         INT      NOT NULL,
    [Hour]            TINYINT  NOT NULL,
    [Value]           SMALLINT NOT NULL,
    [CumulativeValue] SMALLINT NOT NULL,
    [UpdateUserID]    INT      NOT NULL,
    [UpdateDate]      DATETIME NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_TargetHourly1] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [tmp_ms_xx_constraint_IX_Hourly1] UNIQUE NONCLUSTERED ([DailyID] ASC, [Hour] ASC) WITH (FILLFACTOR = 90)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [target].[Hourly])
    BEGIN
        SET IDENTITY_INSERT [target].[tmp_ms_xx_Hourly] ON;
        INSERT INTO [target].[tmp_ms_xx_Hourly] ([ID], [DailyID], [Hour], [Value], [UpdateUserID], [UpdateDate])
        SELECT   [ID],
                 [DailyID],
                 [Hour],
                 [Value],
                 [UpdateUserID],
                 [UpdateDate]
        FROM     [target].[Hourly]
        ORDER BY [ID] ASC;
        SET IDENTITY_INSERT [target].[tmp_ms_xx_Hourly] OFF;
    END

DROP TABLE [target].[Hourly];

EXECUTE sp_rename N'[target].[tmp_ms_xx_Hourly]', N'Hourly';

EXECUTE sp_rename N'[target].[tmp_ms_xx_constraint_PK_TargetHourly1]', N'PK_TargetHourly', N'OBJECT';

EXECUTE sp_rename N'[target].[tmp_ms_xx_constraint_IX_Hourly1]', N'IX_Hourly', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [ver].[Version]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [ver].[tmp_ms_xx_Version] (
    [Id]                       INT            NOT NULL,
    [Version]                  NVARCHAR (8)   NULL,
    [VersionDescription]       NVARCHAR (MAX) NULL,
    [DateStarted]              DATETIME       NOT NULL,
    [DateEnded]                DATETIME       NULL,
    [CompatibleServiceVersion] NVARCHAR (50)  NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [ver].[Version])
    BEGIN
        INSERT INTO [ver].[tmp_ms_xx_Version] ([Id], [Version], [VersionDescription], [DateStarted], [DateEnded], [CompatibleServiceVersion])
        SELECT   [Id],
                 [Version],
                 [VersionDescription],
                 [DateStarted],
                 [DateEnded],
                 [CompatibleServiceVersion]
        FROM     [ver].[Version]
        ORDER BY [Id] ASC;
    END

DROP TABLE [ver].[Version];

EXECUTE sp_rename N'[ver].[tmp_ms_xx_Version]', N'Version';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating [global].[Setting]...';


GO
CREATE TABLE [global].[Setting] (
    [Key]   VARCHAR (50)   NOT NULL,
    [Value] NVARCHAR (MAX) NOT NULL,
    [Note]  NVARCHAR (MAX) NULL,
    CONSTRAINT [PK_Settings] PRIMARY KEY CLUSTERED ([Key] ASC)
);


GO
PRINT N'Creating [layout].[Workbench]...';


GO
CREATE TABLE [layout].[Workbench] (
    [ID]                  INT           IDENTITY (1, 1) NOT NULL,
    [Name]                VARCHAR (50)  NOT NULL,
    [Description]         VARCHAR (MAX) NULL,
    [ExternalReference]   NVARCHAR (50) NOT NULL,
    [CellID]              SMALLINT      NOT NULL,
    [PreviousWorkbenchID] INT           NULL,
    [EOL]                 BIT           NOT NULL,
    [Routing]             SMALLINT      NOT NULL,
    [HourCapacity]        SMALLINT      NOT NULL,
    [TypeID]              VARCHAR (10)  NULL,
    [TimeOut]             TINYINT       NULL,
    CONSTRAINT [PK_Workbench] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Workbench_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [layout].[PartNumber]...';


GO
CREATE TABLE [layout].[PartNumber] (
    [ID]          INT            NOT NULL,
    [PartNumber]  NVARCHAR (50)  NOT NULL,
    [Description] NVARCHAR (MAX) NULL,
    [Routing]     SMALLINT       NOT NULL,
    [Deleted]     BIT            NOT NULL,
    CONSTRAINT [PK_LayoutPartNumber] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_LayoutPartNumber_PartNumber] UNIQUE NONCLUSTERED ([PartNumber] ASC)
);


GO
PRINT N'Creating [layout].[PartNumber].[IX_PartNumber_PartNumber]...';


GO
CREATE NONCLUSTERED INDEX [IX_PartNumber_PartNumber]
    ON [layout].[PartNumber]([PartNumber] ASC);


GO
PRINT N'Creating [layout].[Line]...';


GO
CREATE TABLE [layout].[Line] (
    [ID]          SMALLINT       IDENTITY (1, 1) NOT NULL,
    [Name]        NVARCHAR (50)  NOT NULL,
    [Description] NVARCHAR (MAX) NULL,
    [Tags]        NVARCHAR (MAX) NULL,
    [LocationID]  CHAR (2)       NOT NULL,
    [TimeOut]     TINYINT        NULL,
    [Deleted]     BIT            NOT NULL,
    CONSTRAINT [PK_Line] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Line_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [layout].[Cell]...';


GO
CREATE TABLE [layout].[Cell] (
    [ID]          SMALLINT       IDENTITY (1, 1) NOT NULL,
    [Name]        NVARCHAR (50)  NOT NULL,
    [Description] NVARCHAR (MAX) NULL,
    [LineID]      SMALLINT       NOT NULL,
    [TimeOut]     TINYINT        NULL,
    [Deleted]     BIT            NOT NULL,
    CONSTRAINT [PK_Cell] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Cell_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [layout].[Monitor]...';


GO
CREATE TABLE [layout].[Monitor] (
    [ID]          INT            IDENTITY (1, 1) NOT NULL,
    [Location]    NVARCHAR (50)  NOT NULL,
    [Description] NVARCHAR (255) NOT NULL,
    [IPAddress]   NVARCHAR (50)  NULL,
    [LocationID]  CHAR (2)       NOT NULL,
    [LineID]      SMALLINT       NULL,
    [Deleted]     BIT            NOT NULL,
    CONSTRAINT [PK_Monitor] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [layout].[Location]...';


GO
CREATE TABLE [layout].[Location] (
    [ID]      CHAR (2)      NOT NULL,
    [Name]    NVARCHAR (50) NOT NULL,
    [Deleted] BIT           NOT NULL,
    CONSTRAINT [PK_Location] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Location_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [layout].[WorkbenchType]...';


GO
CREATE TABLE [layout].[WorkbenchType] (
    [ID]          VARCHAR (10)   NOT NULL,
    [Name]        NVARCHAR (50)  NOT NULL,
    [Description] NVARCHAR (MAX) NULL,
    CONSTRAINT [PK_WorkbenchType] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_WorkbenchType_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [layout].[WorkbenchStatus]...';


GO
CREATE TABLE [layout].[WorkbenchStatus] (
    [WorkbenchID]       INT      NOT NULL,
    [LoggedInProfileID] INT      NULL,
    [HasErrorTimeStamp] DATETIME NULL,
    [ErrorId]           INT      NULL,
    [LastChanged]       DATETIME NOT NULL,
    CONSTRAINT [PK_WorkbenchStatus_WorkbenchId] PRIMARY KEY CLUSTERED ([WorkbenchID] ASC)
);


GO
PRINT N'Creating [layout].[LineTag]...';


GO
CREATE TABLE [layout].[LineTag] (
    [LineID] SMALLINT      NOT NULL,
    [Tag]    NVARCHAR (50) NOT NULL,
    CONSTRAINT [PK_LineTag] PRIMARY KEY CLUSTERED ([LineID] ASC, [Tag] ASC)
);


GO
PRINT N'Creating [log].[ProcedureLog]...';


GO
CREATE TABLE [log].[ProcedureLog] (
    [ID]           BIGINT         IDENTITY (1, 1) NOT NULL,
    [ProcedureID]  TINYINT        NOT NULL,
    [ProfileID]    BIGINT         NULL,
    [CustomParams] NVARCHAR (MAX) NULL,
    [XMLParam]     XML            NULL,
    [Message]      NVARCHAR (MAX) NULL,
    [ErrorID]      INT            NULL,
    [DboError]     INT            NULL,
    [DevError]     NVARCHAR (MAX) NULL,
    [TimeStamp]    DATETIME       NOT NULL,
    CONSTRAINT [PK_ProcedureLog] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [log].[Procedure]...';


GO
CREATE TABLE [log].[Procedure] (
    [ID]   TINYINT        NOT NULL,
    [Name] NVARCHAR (MAX) NOT NULL,
    [Api]  BIT            NULL,
    CONSTRAINT [PK_Procedure] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [users].[Profile]...';


GO
CREATE TABLE [users].[Profile] (
    [ID]         INT            IDENTITY (1, 1) NOT NULL,
    [Deleted]    BIT            NULL,
    [FirstName]  NVARCHAR (255) NOT NULL,
    [LastName]   NVARCHAR (255) NOT NULL,
    [LevelID]    SMALLINT       NOT NULL,
    [Barcode]    NVARCHAR (50)  NULL,
    [IsActive]   BIT            NULL,
    [OperatorID] INT            NULL,
    [CreatedAt]  DATETIME       NOT NULL,
    [UpdatedAt]  DATETIME       NULL,
    CONSTRAINT [PK_Profile_ID] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Profile_Barcode] UNIQUE NONCLUSTERED ([Barcode] ASC)
);


GO
PRINT N'Creating [users].[Operator]...';


GO
CREATE TABLE [users].[Operator] (
    [ID]                  INT            IDENTITY (1, 1) NOT NULL,
    [ValidEntry]          BIT            NOT NULL,
    [Barcode]             NVARCHAR (50)  NOT NULL,
    [FirstName]           NVARCHAR (255) NOT NULL,
    [LastName]            NVARCHAR (255) NOT NULL,
    [SecurityLevel]       INT            NOT NULL,
    [Role]                NVARCHAR (50)  NULL,
    [IsActive]            BIT            NOT NULL,
    [Deleted]             BIT            NOT NULL,
    [CreateTimeStamp]     DATETIME       NOT NULL,
    [LastUpdateTimeStamp] DATETIME       NULL,
    CONSTRAINT [PK_Operator] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Operator_Barcode] UNIQUE NONCLUSTERED ([Barcode] ASC) WITH (FILLFACTOR = 90)
);


GO
PRINT N'Creating [users].[Level]...';


GO
CREATE TABLE [users].[Level] (
    [ID]   SMALLINT       NOT NULL,
    [Name] NVARCHAR (50)  NOT NULL,
    [Help] NVARCHAR (MAX) NULL,
    CONSTRAINT [PK_UserLevel_ID] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [users].[AccountToken]...';


GO
CREATE TABLE [users].[AccountToken] (
    [ID]              INT            IDENTITY (1, 1) NOT NULL,
    [AccountID]       INT            NOT NULL,
    [WorkbenchID]     INT            NULL,
    [Token]           NVARCHAR (MAX) NOT NULL,
    [Expire]          DATETIME       NOT NULL,
    [LoginTime]       DATETIME       NOT NULL,
    [LogoutTime]      DATETIME       NULL,
    [IsActive]        BIT            NOT NULL,
    [AutomaticLogout] BIT            NULL,
    CONSTRAINT [PK_AccountToken] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [users].[AccountProvider]...';


GO
CREATE TABLE [users].[AccountProvider] (
    [ID]   SMALLINT      NOT NULL,
    [Name] NVARCHAR (50) NOT NULL,
    CONSTRAINT [PK_UserAccountProvider_ID] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [users].[AccountLoginHistory]...';


GO
CREATE TABLE [users].[AccountLoginHistory] (
    [ID]         INT      NOT NULL,
    [AccountID]  INT      NOT NULL,
    [LoginTime]  DATETIME NOT NULL,
    [LogoutTime] DATETIME NULL,
    [IsActive]   BIT      NOT NULL
);


GO
PRINT N'Creating [users].[Account]...';


GO
CREATE TABLE [users].[Account] (
    [ID]                         INT            IDENTITY (1, 1) NOT NULL,
    [CreatedAt]                  DATETIME       NOT NULL,
    [UpdatedAt]                  DATETIME       NULL,
    [Deleted]                    BIT            NULL,
    [Username]                   NVARCHAR (50)  NOT NULL,
    [Password]                   NVARCHAR (50)  NOT NULL,
    [AccountProviderUniqueAppID] NVARCHAR (100) NOT NULL,
    [AccountProviderID]          SMALLINT       NOT NULL,
    [ProfileID]                  INT            NOT NULL,
    CONSTRAINT [PK_Account_ID] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Account_Profile_AccountProvider] UNIQUE NONCLUSTERED ([ProfileID] ASC, [AccountProviderID] ASC)
);


GO
PRINT N'Creating [users].[Feature]...';


GO
CREATE TABLE [users].[Feature] (
    [ID]               VARCHAR (250) NOT NULL,
    [RequestorLevelID] SMALLINT      NOT NULL,
    [TargetLevelID]    SMALLINT      NOT NULL,
    [Operation]        CHAR (1)      NULL,
    [UpdateUserID]     INT           NOT NULL,
    [UpdateDate]       DATETIME      NOT NULL,
    CONSTRAINT [PK_Feature] PRIMARY KEY CLUSTERED ([ID] ASC, [TargetLevelID] ASC)
);


GO
PRINT N'Creating [dbo].[ActualsLog]...';


GO
CREATE TABLE [dbo].[ActualsLog] (
    [ID]         NVARCHAR (50) NOT NULL,
    [Date]       DATETIME      NOT NULL,
    [ShiftType]  CHAR (1)      NOT NULL,
    [Workbench]  NVARCHAR (50) NOT NULL,
    [PartNumber] NVARCHAR (50) NOT NULL,
    [IsOK]       BIT           NOT NULL,
    CONSTRAINT [PK_ActualsLog] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [dbo].[CommentsDictionary]...';


GO
CREATE TABLE [dbo].[CommentsDictionary] (
    [ID]      INT            IDENTITY (1, 1) NOT NULL,
    [Text]    NVARCHAR (100) NOT NULL,
    [Deleted] BIT            NOT NULL,
    CONSTRAINT [PK_CommentsDictionary] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [dbo].[Downtime]...';


GO
CREATE TABLE [dbo].[Downtime] (
    [ID]             INT      IDENTITY (1, 1) NOT NULL,
    [TargetHourlyID] INT      NOT NULL,
    [WorkbenchID]    INT      NOT NULL,
    [DataStart]      DATETIME NOT NULL,
    [DataEnd]        DATETIME NOT NULL,
    CONSTRAINT [PK_Downtime] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [dbo].[DowntimeDetails]...';


GO
CREATE TABLE [dbo].[DowntimeDetails] (
    [ID]         INT            IDENTITY (1, 1) NOT NULL,
    [DowntimeID] INT            NOT NULL,
    [Comment]    NVARCHAR (100) NOT NULL,
    [Duration]   SMALLINT       NOT NULL,
    [UpdateDate] DATETIME       NOT NULL,
    CONSTRAINT [PK_DowntimeDetails] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [dbo].[DowntimeDictionary]...';


GO
CREATE TABLE [dbo].[DowntimeDictionary] (
    [ID]      INT            IDENTITY (1, 1) NOT NULL,
    [Text]    NVARCHAR (100) NOT NULL,
    [Deleted] BIT            NOT NULL,
    CONSTRAINT [PK_DowntimeDictionary] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [dbo].[Error]...';


GO
CREATE TABLE [dbo].[Error] (
    [ID]                INT            NOT NULL,
    [ValidEntry]        BIT            NOT NULL,
    [Barcode]           NVARCHAR (50)  NULL,
    [Description]       NVARCHAR (255) NOT NULL,
    [Help]              NVARCHAR (MAX) NOT NULL,
    [RecommendedAction] NVARCHAR (255) NULL,
    [CriticalError]     BIT            NOT NULL,
    [EmailSubject]      NVARCHAR (255) NULL,
    [EmailStringFormat] NVARCHAR (255) NULL,
    [ToEmail]           NVARCHAR (255) NULL,
    [CCEmail]           NVARCHAR (255) NULL,
    [BCCEmail]          NVARCHAR (255) NULL,
    [Deleted]           BIT            NOT NULL,
    [Type]              NVARCHAR (30)  NOT NULL,
    [InternalAlias]     NVARCHAR (255) NOT NULL,
    CONSTRAINT [PK_ErrorType] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_Error_Barcode] UNIQUE NONCLUSTERED ([Barcode] ASC) WITH (FILLFACTOR = 90),
    CONSTRAINT [IX_Error_InternalAlias] UNIQUE NONCLUSTERED ([InternalAlias] ASC) WITH (FILLFACTOR = 90)
);


GO
PRINT N'Creating [dbo].[EscalatedDictionary]...';


GO
CREATE TABLE [dbo].[EscalatedDictionary] (
    [ID]      INT           IDENTITY (1, 1) NOT NULL,
    [Text]    NVARCHAR (50) NOT NULL,
    [Deleted] BIT           NOT NULL,
    CONSTRAINT [PK_EscalatedDictionary] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [target].[PartNumber]...';


GO
CREATE TABLE [target].[PartNumber] (
    [ID]           INT      IDENTITY (1, 1) NOT NULL,
    [DailyID]      INT      NOT NULL,
    [PartNumberID] INT      NOT NULL,
    [Priority]     SMALLINT NOT NULL,
    [InitialQty]   SMALLINT NOT NULL,
    [Value]        SMALLINT NOT NULL,
    [UpdateUserID] INT      NOT NULL,
    [UpdateDate]   DATETIME NOT NULL,
    CONSTRAINT [PK_TargetPartNumber] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [IX_TargetPartNumber] UNIQUE NONCLUSTERED ([DailyID] ASC, [Priority] ASC) WITH (FILLFACTOR = 90)
);


GO
PRINT N'Creating [target].[Type]...';


GO
CREATE TABLE [target].[Type] (
    [ID]   CHAR (2)     NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [ver].[Tables]...';


GO
CREATE TABLE [ver].[Tables] (
    [Schema]     VARCHAR (250) NOT NULL,
    [Name]       VARCHAR (250) NOT NULL,
    [Dictionary] BIT           NOT NULL,
    [VersionId]  INT           NULL,
    CONSTRAINT [PK_Tables_Schema_Name] PRIMARY KEY CLUSTERED ([Schema] ASC, [Name] ASC)
);


GO
PRINT N'Creating [layout].[DF_Workbench_HourCapacity]...';


GO
ALTER TABLE [layout].[Workbench]
    ADD CONSTRAINT [DF_Workbench_HourCapacity] DEFAULT 0 FOR [HourCapacity];


GO
PRINT N'Creating [layout].[DF_PartNumber_Deleted]...';


GO
ALTER TABLE [layout].[PartNumber]
    ADD CONSTRAINT [DF_PartNumber_Deleted] DEFAULT 0 FOR [Deleted];


GO
PRINT N'Creating [layout].[DF_Line_Deleted]...';


GO
ALTER TABLE [layout].[Line]
    ADD CONSTRAINT [DF_Line_Deleted] DEFAULT 0 FOR [Deleted];


GO
PRINT N'Creating [layout].[DF_Cell_Deleted]...';


GO
ALTER TABLE [layout].[Cell]
    ADD CONSTRAINT [DF_Cell_Deleted] DEFAULT 0 FOR [Deleted];


GO
PRINT N'Creating [layout].[DF_Monitor_IPAddress]...';


GO
ALTER TABLE [layout].[Monitor]
    ADD CONSTRAINT [DF_Monitor_IPAddress] DEFAULT (N'255.255.255.255') FOR [IPAddress];


GO
PRINT N'Creating [layout].[DF_Monitor_Deleted]...';


GO
ALTER TABLE [layout].[Monitor]
    ADD CONSTRAINT [DF_Monitor_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [layout].[DF_Location_Deleted]...';


GO
ALTER TABLE [layout].[Location]
    ADD CONSTRAINT [DF_Location_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [log].[DF_ProcedureLog_DboError]...';


GO
ALTER TABLE [log].[ProcedureLog]
    ADD CONSTRAINT [DF_ProcedureLog_DboError] DEFAULT ((0)) FOR [DboError];


GO
PRINT N'Creating [users].[DF_UserProfile_Deleted]...';


GO
ALTER TABLE [users].[Profile]
    ADD CONSTRAINT [DF_UserProfile_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [users].[DF_UserProfile_Level]...';


GO
ALTER TABLE [users].[Profile]
    ADD CONSTRAINT [DF_UserProfile_Level] DEFAULT ((0)) FOR [LevelID];


GO
PRINT N'Creating [users].[DF_UserProfile_Active]...';


GO
ALTER TABLE [users].[Profile]
    ADD CONSTRAINT [DF_UserProfile_Active] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating [users].[DF_Operator_ValidEntry]...';


GO
ALTER TABLE [users].[Operator]
    ADD CONSTRAINT [DF_Operator_ValidEntry] DEFAULT ((1)) FOR [ValidEntry];


GO
PRINT N'Creating [users].[DF_Operator_SecurityLevel]...';


GO
ALTER TABLE [users].[Operator]
    ADD CONSTRAINT [DF_Operator_SecurityLevel] DEFAULT ((0)) FOR [SecurityLevel];


GO
PRINT N'Creating [users].[DF_Operator_IsActive]...';


GO
ALTER TABLE [users].[Operator]
    ADD CONSTRAINT [DF_Operator_IsActive] DEFAULT ((0)) FOR [IsActive];


GO
PRINT N'Creating [users].[DF_Operator_Deleted]...';


GO
ALTER TABLE [users].[Operator]
    ADD CONSTRAINT [DF_Operator_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating unnamed constraint on [users].[AccountToken]...';


GO
ALTER TABLE [users].[AccountToken]
    ADD DEFAULT (1) FOR [IsActive];


GO
PRINT N'Creating [users].[DF_UserAccountLoginHistory_IsActive]...';


GO
ALTER TABLE [users].[AccountLoginHistory]
    ADD CONSTRAINT [DF_UserAccountLoginHistory_IsActive] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating unnamed constraint on [users].[Account]...';


GO
ALTER TABLE [users].[Account]
    ADD DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [dbo].[DF_CommentsDictionary_Deleted]...';


GO
ALTER TABLE [dbo].[CommentsDictionary]
    ADD CONSTRAINT [DF_CommentsDictionary_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [dbo].[DF_DowntimeDictionary_Deleted]...';


GO
ALTER TABLE [dbo].[DowntimeDictionary]
    ADD CONSTRAINT [DF_DowntimeDictionary_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [dbo].[DF_ErrorType_ValidEntry]...';


GO
ALTER TABLE [dbo].[Error]
    ADD CONSTRAINT [DF_ErrorType_ValidEntry] DEFAULT ((1)) FOR [ValidEntry];


GO
PRINT N'Creating [dbo].[DF_Error_Deleted]...';


GO
ALTER TABLE [dbo].[Error]
    ADD CONSTRAINT [DF_Error_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [dbo].[DF_Error_Type]...';


GO
ALTER TABLE [dbo].[Error]
    ADD CONSTRAINT [DF_Error_Type] DEFAULT (N'Error') FOR [Type];


GO
PRINT N'Creating [dbo].[DF_EscalatedDictionary_Deleted]...';


GO
ALTER TABLE [dbo].[EscalatedDictionary]
    ADD CONSTRAINT [DF_EscalatedDictionary_Deleted] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating unnamed constraint on [ver].[Tables]...';


GO
ALTER TABLE [ver].[Tables]
    ADD DEFAULT ((1)) FOR [Dictionary];


GO
PRINT N'Creating [dbo].[FK_ShiftLogSignOff_ShiftLog]...';


GO
ALTER TABLE [dbo].[ShiftLogSignOff] WITH NOCHECK
    ADD CONSTRAINT [FK_ShiftLogSignOff_ShiftLog] FOREIGN KEY ([ShiftLogID]) REFERENCES [dbo].[ShiftLog] ([ID]);


GO
PRINT N'Creating [dbo].[FK_ShiftLog_PreviousShiftLog]...';


GO
ALTER TABLE [dbo].[ShiftLog] WITH NOCHECK
    ADD CONSTRAINT [FK_ShiftLog_PreviousShiftLog] FOREIGN KEY ([PreviousShiftLogID]) REFERENCES [dbo].[ShiftLog] ([ID]);


GO
PRINT N'Creating [dbo].[FK_ShiftLogBreak_ShiftLog]...';


GO
ALTER TABLE [dbo].[ShiftLogBreak] WITH NOCHECK
    ADD CONSTRAINT [FK_ShiftLogBreak_ShiftLog] FOREIGN KEY ([ShiftLogID]) REFERENCES [dbo].[ShiftLog] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetDaily_ShiftLog]...';


GO
ALTER TABLE [target].[Daily] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetDaily_ShiftLog] FOREIGN KEY ([ShiftLogID]) REFERENCES [dbo].[ShiftLog] ([ID]);


GO
PRINT N'Creating [dbo].[FK_ShiftLog_Location]...';


GO
ALTER TABLE [dbo].[ShiftLog] WITH NOCHECK
    ADD CONSTRAINT [FK_ShiftLog_Location] FOREIGN KEY ([LocationID]) REFERENCES [layout].[Location] ([ID]);


GO
PRINT N'Creating [dbo].[FK_ShiftLogSignOff_Line]...';


GO
ALTER TABLE [dbo].[ShiftLogSignOff] WITH NOCHECK
    ADD CONSTRAINT [FK_ShiftLogSignOff_Line] FOREIGN KEY ([LineID]) REFERENCES [layout].[Line] ([ID]);


GO
PRINT N'Creating [dbo].[FK_ShiftLogSignOff_SignedOffOperator]...';


GO
ALTER TABLE [dbo].[ShiftLogSignOff] WITH NOCHECK
    ADD CONSTRAINT [FK_ShiftLogSignOff_SignedOffOperator] FOREIGN KEY ([SignedOffOperatorID]) REFERENCES [users].[Operator] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetHourly_TargetDaily]...';


GO
ALTER TABLE [target].[Hourly] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetHourly_TargetDaily] FOREIGN KEY ([DailyID]) REFERENCES [target].[Daily] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetDaily_Type]...';


GO
ALTER TABLE [target].[Daily] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetDaily_Type] FOREIGN KEY ([TypeID]) REFERENCES [target].[Type] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetDaily_Line]...';


GO
ALTER TABLE [target].[Daily] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetDaily_Line] FOREIGN KEY ([LineID]) REFERENCES [layout].[Line] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetDaily_UpdateUser]...';


GO
ALTER TABLE [target].[Daily] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetDaily_UpdateUser] FOREIGN KEY ([UpdateUserID]) REFERENCES [users].[Profile] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetHourly_UpdateUser]...';


GO
ALTER TABLE [target].[Hourly] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetHourly_UpdateUser] FOREIGN KEY ([UpdateUserID]) REFERENCES [users].[Profile] ([ID]);


GO
PRINT N'Creating [layout].[FK_Workbench_Type]...';


GO
ALTER TABLE [layout].[Workbench] WITH NOCHECK
    ADD CONSTRAINT [FK_Workbench_Type] FOREIGN KEY ([TypeID]) REFERENCES [layout].[WorkbenchType] ([ID]);


GO
PRINT N'Creating [layout].[FK_Workbench_Cell]...';


GO
ALTER TABLE [layout].[Workbench] WITH NOCHECK
    ADD CONSTRAINT [FK_Workbench_Cell] FOREIGN KEY ([CellID]) REFERENCES [layout].[Cell] ([ID]);


GO
PRINT N'Creating [layout].[FK_Workbench_PreviousWorkbench]...';


GO
ALTER TABLE [layout].[Workbench] WITH NOCHECK
    ADD CONSTRAINT [FK_Workbench_PreviousWorkbench] FOREIGN KEY ([PreviousWorkbenchID]) REFERENCES [layout].[Workbench] ([ID]);


GO
PRINT N'Creating [layout].[FK_Line_Location]...';


GO
ALTER TABLE [layout].[Line] WITH NOCHECK
    ADD CONSTRAINT [FK_Line_Location] FOREIGN KEY ([LocationID]) REFERENCES [layout].[Location] ([ID]);


GO
PRINT N'Creating [layout].[FK_Cell_Line]...';


GO
ALTER TABLE [layout].[Cell] WITH NOCHECK
    ADD CONSTRAINT [FK_Cell_Line] FOREIGN KEY ([LineID]) REFERENCES [layout].[Line] ([ID]);


GO
PRINT N'Creating [layout].[FK_Monitor_Line]...';


GO
ALTER TABLE [layout].[Monitor] WITH NOCHECK
    ADD CONSTRAINT [FK_Monitor_Line] FOREIGN KEY ([LineID]) REFERENCES [layout].[Line] ([ID]);


GO
PRINT N'Creating [layout].[FK_Monitor_Location]...';


GO
ALTER TABLE [layout].[Monitor] WITH NOCHECK
    ADD CONSTRAINT [FK_Monitor_Location] FOREIGN KEY ([LocationID]) REFERENCES [layout].[Location] ([ID]);


GO
PRINT N'Creating [layout].[FK_WorkbenchStatus_Workbench]...';


GO
ALTER TABLE [layout].[WorkbenchStatus] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkbenchStatus_Workbench] FOREIGN KEY ([WorkbenchID]) REFERENCES [layout].[Workbench] ([ID]);


GO
PRINT N'Creating [layout].[FK_WorkbenchStatus_ErrorId]...';


GO
ALTER TABLE [layout].[WorkbenchStatus] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkbenchStatus_ErrorId] FOREIGN KEY ([ErrorId]) REFERENCES [dbo].[Error] ([ID]);


GO
PRINT N'Creating [layout].[FK_LineTag_Line]...';


GO
ALTER TABLE [layout].[LineTag] WITH NOCHECK
    ADD CONSTRAINT [FK_LineTag_Line] FOREIGN KEY ([LineID]) REFERENCES [layout].[Line] ([ID]);


GO
PRINT N'Creating [log].[FK_ProcedureLog_Procedure]...';


GO
ALTER TABLE [log].[ProcedureLog] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLog_Procedure] FOREIGN KEY ([ProcedureID]) REFERENCES [log].[Procedure] ([ID]);


GO
PRINT N'Creating [users].[FK_AccountToken_Account]...';


GO
ALTER TABLE [users].[AccountToken] WITH NOCHECK
    ADD CONSTRAINT [FK_AccountToken_Account] FOREIGN KEY ([AccountID]) REFERENCES [users].[Account] ([ID]);


GO
PRINT N'Creating [users].[FK_AccountLoginHistory_Account]...';


GO
ALTER TABLE [users].[AccountLoginHistory] WITH NOCHECK
    ADD CONSTRAINT [FK_AccountLoginHistory_Account] FOREIGN KEY ([AccountID]) REFERENCES [users].[Account] ([ID]);


GO
PRINT N'Creating [users].[FK_Account_AccountProvider]...';


GO
ALTER TABLE [users].[Account] WITH NOCHECK
    ADD CONSTRAINT [FK_Account_AccountProvider] FOREIGN KEY ([AccountProviderID]) REFERENCES [users].[AccountProvider] ([ID]);


GO
PRINT N'Creating [users].[FK_Account_Profile]...';


GO
ALTER TABLE [users].[Account] WITH NOCHECK
    ADD CONSTRAINT [FK_Account_Profile] FOREIGN KEY ([ProfileID]) REFERENCES [users].[Profile] ([ID]);


GO
PRINT N'Creating [users].[FK_Feature_RequestorLevel]...';


GO
ALTER TABLE [users].[Feature] WITH NOCHECK
    ADD CONSTRAINT [FK_Feature_RequestorLevel] FOREIGN KEY ([RequestorLevelID]) REFERENCES [users].[Level] ([ID]);


GO
PRINT N'Creating [users].[FK_Feature_TargetLevel]...';


GO
ALTER TABLE [users].[Feature] WITH NOCHECK
    ADD CONSTRAINT [FK_Feature_TargetLevel] FOREIGN KEY ([TargetLevelID]) REFERENCES [users].[Level] ([ID]);


GO
PRINT N'Creating [users].[FK_Feature_UpdateUser]...';


GO
ALTER TABLE [users].[Feature] WITH NOCHECK
    ADD CONSTRAINT [FK_Feature_UpdateUser] FOREIGN KEY ([UpdateUserID]) REFERENCES [users].[Profile] ([ID]);


GO
PRINT N'Creating [dbo].[FK_Downtime_TargetHourly]...';


GO
ALTER TABLE [dbo].[Downtime] WITH NOCHECK
    ADD CONSTRAINT [FK_Downtime_TargetHourly] FOREIGN KEY ([TargetHourlyID]) REFERENCES [target].[Hourly] ([ID]);


GO
PRINT N'Creating [dbo].[FK_Downtime_Workbench]...';


GO
ALTER TABLE [dbo].[Downtime] WITH NOCHECK
    ADD CONSTRAINT [FK_Downtime_Workbench] FOREIGN KEY ([WorkbenchID]) REFERENCES [layout].[Workbench] ([ID]);


GO
PRINT N'Creating [dbo].[FK_DowntimeDetails_Downtime]...';


GO
ALTER TABLE [dbo].[DowntimeDetails] WITH NOCHECK
    ADD CONSTRAINT [FK_DowntimeDetails_Downtime] FOREIGN KEY ([DowntimeID]) REFERENCES [dbo].[Downtime] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetPartNumber_Daily]...';


GO
ALTER TABLE [target].[PartNumber] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetPartNumber_Daily] FOREIGN KEY ([DailyID]) REFERENCES [target].[Daily] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetPartNumber_LayoutPartNumber]...';


GO
ALTER TABLE [target].[PartNumber] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetPartNumber_LayoutPartNumber] FOREIGN KEY ([PartNumberID]) REFERENCES [layout].[PartNumber] ([ID]);


GO
PRINT N'Creating [target].[FK_TargetPartNumber_UpdateUser]...';


GO
ALTER TABLE [target].[PartNumber] WITH NOCHECK
    ADD CONSTRAINT [FK_TargetPartNumber_UpdateUser] FOREIGN KEY ([UpdateUserID]) REFERENCES [users].[Profile] ([ID]);


GO
PRINT N'Creating [ver].[FK_Tables_Version]...';


GO
ALTER TABLE [ver].[Tables] WITH NOCHECK
    ADD CONSTRAINT [FK_Tables_Version] FOREIGN KEY ([VersionId]) REFERENCES [ver].[Version] ([Id]);


GO
PRINT N'Creating [dbo].[CK_ShiftLog_PreviousShiftLogID]...';


GO
ALTER TABLE [dbo].[ShiftLog] WITH NOCHECK
    ADD CONSTRAINT [CK_ShiftLog_PreviousShiftLogID] CHECK ([PreviousShiftLogID] IS NULL OR [PreviousShiftLogID]<[ID]);


GO
PRINT N'Creating [dbo].[CK_ShiftLog_ShiftType]...';


GO
ALTER TABLE [dbo].[ShiftLog] WITH NOCHECK
    ADD CONSTRAINT [CK_ShiftLog_ShiftType] CHECK ([ShiftType]='C' OR [ShiftType]='B' OR [ShiftType]='A');


GO
PRINT N'Creating [dbo].[CK_ShiftLogBreak_TimeEnd]...';


GO
ALTER TABLE [dbo].[ShiftLogBreak] WITH NOCHECK
    ADD CONSTRAINT [CK_ShiftLogBreak_TimeEnd] CHECK (TimeEnd > TimeStart);


GO
PRINT N'Creating [target].[CK_TargetDaily_Value]...';


GO
ALTER TABLE [target].[Daily] WITH NOCHECK
    ADD CONSTRAINT [CK_TargetDaily_Value] CHECK ([Value]>=(0));


GO
PRINT N'Creating [target].[CK_TargeHourly_Value]...';


GO
ALTER TABLE [target].[Hourly] WITH NOCHECK
    ADD CONSTRAINT [CK_TargeHourly_Value] CHECK ([Value]>=(0));


GO
PRINT N'Creating [target].[CK_TargetHourly_CumulativeValue]...';


GO
ALTER TABLE [target].[Hourly] WITH NOCHECK
    ADD CONSTRAINT [CK_TargetHourly_CumulativeValue] CHECK ([CumulativeValue] >= [Value]);


GO
PRINT N'Creating [target].[CK_TargetHourly_Hour]...';


GO
ALTER TABLE [target].[Hourly] WITH NOCHECK
    ADD CONSTRAINT [CK_TargetHourly_Hour] CHECK ([Hour]>=(1) AND [Hour]<=(8));


GO
PRINT N'Creating [layout].[CK_Monitor_IP]...';


GO
ALTER TABLE [layout].[Monitor] WITH NOCHECK
    ADD CONSTRAINT [CK_Monitor_IP] CHECK (([IPAddress] like '%_.%_.%_.%_' AND NOT [IPAddress] like '%.%.%.%.%' AND NOT [IPAddress] like '%[^0-9.]%' AND NOT [IPAddress] like '%[0-9][0-9][0-9][0-9]%' AND NOT [IPAddress] like '%[3-9][0-9][0-9]%' AND NOT [IPAddress] like '%2[6-9][0-9]%' AND NOT [IPAddress] like '%25[6-9]%'));


GO
PRINT N'Creating [users].[CK_Profile_Operator]...';


GO
ALTER TABLE [users].[Profile] WITH NOCHECK
    ADD CONSTRAINT [CK_Profile_Operator] CHECK ([OperatorID] is NULL or ([OperatorID] is not NULL and [Deleted] = 0));


GO
PRINT N'Creating [users].[CK_Operator_IsActive]...';


GO
ALTER TABLE [users].[Operator] WITH NOCHECK
    ADD CONSTRAINT [CK_Operator_IsActive] CHECK ([IsActive]=(0) OR [Deleted]=(0));


GO
PRINT N'Creating [users].[CK_AccountLoginHistory_LogouTime]...';


GO
ALTER TABLE [users].[AccountLoginHistory] WITH NOCHECK
    ADD CONSTRAINT [CK_AccountLoginHistory_LogouTime] CHECK ([LogoutTime] > [LoginTime]);


GO
PRINT N'Creating [users].[CK_Feature_RequestorLevelID]...';


GO
ALTER TABLE [users].[Feature] WITH NOCHECK
    ADD CONSTRAINT [CK_Feature_RequestorLevelID] CHECK (RequestorLevelID = 1 or RequestorLevelID < TargetLevelID);


GO
PRINT N'Creating [dbo].[CK_Downtime_DataEnd]...';


GO
ALTER TABLE [dbo].[Downtime] WITH NOCHECK
    ADD CONSTRAINT [CK_Downtime_DataEnd] CHECK ([DataEnd] > [DataStart]);


GO
PRINT N'Creating [dbo].[CK_DowntimeDetails_Duration]...';


GO
ALTER TABLE [dbo].[DowntimeDetails] WITH NOCHECK
    ADD CONSTRAINT [CK_DowntimeDetails_Duration] CHECK ([Duration] >= (0));


GO
PRINT N'Creating [target].[CK_TargetPartNumber_Value]...';


GO
ALTER TABLE [target].[PartNumber] WITH NOCHECK
    ADD CONSTRAINT [CK_TargetPartNumber_Value] CHECK ([Value]>=(0));


GO
PRINT N'Creating [dbo].[ShiftLogBreak_CheckTimeBetweenShiftLimits]...';


GO

CREATE TRIGGER [dbo].[ShiftLogBreak_CheckTimeBetweenShiftLimits]
ON [dbo].[ShiftLogBreak]
FOR INSERT, UPDATE
    AS
    BEGIN
        SET NoCount ON

		declare @time nvarchar(20)
		select top 1 @time = CONVERT(nvarchar(20), i.TimeStart, 120)
		from inserted i
			inner join dbo.ShiftLog sl on i.ShiftLogID = sl.ID
			inner join dbo.ShiftLog slp on sl.ID = slp.PreviousShiftLogID
		where i.TimeStart < sl.DataStart
			or i.TimeStart >= slp.DataStart

		if @time is not NULL
		begin
			rollback tran
			raiserror(N'Break start time %s is not in the time limit of associated shift.', 16, 1, @time)
		end
				
		select top 1 @time = CONVERT(nvarchar(20), i.TimeStart, 120)
		from inserted i
			inner join dbo.ShiftLog sl on i.ShiftLogID = sl.ID
			inner join dbo.ShiftLog slp on sl.ID = slp.PreviousShiftLogID
		where i.TimeEnd < sl.DataStart
			or i.TimeEnd >= slp.DataStart

		if @time is not NULL
		begin
			rollback tran
			raiserror(N'Break end time %s is not in the time limit of associated shift.', 16, 1, @time)
		end
    END
GO
PRINT N'Creating [target].[targetDaily_CheckUniqueShiftOnBillboard_InsertUpdate]...';


GO

CREATE TRIGGER [target].[targetDaily_CheckUniqueShiftOnBillboard_InsertUpdate]
    ON [target].[Daily]
    FOR DELETE, INSERT, UPDATE
AS
BEGIN
    SET NoCount ON

	declare @shift nvarchar(50)

	if UPDATE(Billboard) or UPDATE(ShiftLogID)
	begin
		select top 1 @shift = N'Line ' + l.[Name] + N' on ' + CONVERT(nvarchar(10), sl.[Data], 121) + N' shift ' + sl.ShiftType
		from [target].[Daily] d
			inner join dbo.ShiftLog sl on d.ShiftLogID = sl.ID
			inner join layout.Line l on d.LineID = l.ID
		where d.Billboard = 1
		group by sl.[Data], l.[Name], sl.ShiftType
		having COUNT(*) > 1

		if @shift is not NULL
		begin
			rollback tran
			raiserror(N'With present planning data set modifications you will have in billboard 2 or more records with the same date/shift %s>.', 16, 1, @shift)
		end
	end
END
GO
PRINT N'Creating [layout].[Monitor_CheckUniqueConstraints_InsertUpdate]...';


GO

CREATE TRIGGER [layout].[Monitor_CheckUniqueConstraints_InsertUpdate]
    ON [layout].[Monitor]
    FOR INSERT, UPDATE
AS
BEGIN
    SET NoCount ON

	declare @locationID char(2),
			@ipAddress nvarchar(50)

	if UPDATE(LocationID) or UPDATE(IPAddress)
	begin
		select top 1
			@locationID = LocationID,
			@ipAddress = IPAddress
		from layout.Monitor
		where Deleted = 0
		group by LocationID, IPAddress
		having COUNT(*) > 1

		if @locationID is not NULL
		begin
			rollback tran
			raiserror(N'With present monitor modifications you will have 2 or more records with the same combination Location / IP address <%s / %s>.', 16, 1, @locationID, @ipAddress)
		end
	end

END
GO
PRINT N'Creating [layout].[LineTag_GenerateTags_InsertUpdateDelete]...';


GO

CREATE TRIGGER [layout].[LineTag_GenerateTags_InsertUpdateDelete]
    ON [layout].[LineTag]
    FOR DELETE, INSERT, UPDATE
    AS
    BEGIN
        SET NoCount ON
		
		declare @lines	table(ID smallint NOT NULL PRIMARY KEY, Tags nvarchar(MAX))
		declare @tags	nvarchar(MAX),
				@id		smallint = 0

		insert into @lines(ID)
		select LineID from Inserted
		union
		select LineID from Deleted

		while 1=1
		begin
			select top 1
				@id = ID, @tags = N''
			from @lines
			where ID > @id
			order by ID
			if @@ROWCOUNT = 0 break

			select @tags += Tag + N';'
			from layout.LineTag
			where LineID = @id

			update @lines
			set Tags = @tags
			where ID = @id
		end

		update l
		set Tags = _l.Tags
		from @lines _l
			inner join layout.Line l on _l.ID = l.ID

    END
GO
PRINT N'Creating [users].[Profile_CheckUniqueOperator_InsertUpdate]...';


GO

CREATE TRIGGER [users].[Profile_CheckUniqueOperator_InsertUpdate]
    ON [users].[Profile]
    FOR INSERT, UPDATE
    AS
    BEGIN
        SET NoCount ON

		declare @operatorBarcode nvarchar(50)
		select @operatorBarcode = o.Barcode
		from (
			select OperatorID
			from users.[Profile]
			where OperatorID is not NULL
				and Deleted = 0
			group by OperatorID
			having COUNT(ID) > 1
		) p
			inner join users.Operator o on p.OperatorID = o.ID
			
		group by o.Barcode
		having COUNT(o.ID) > 1

		if @operatorBarcode is not NULL
		begin
			rollback tran
			raiserror(N'With present profile modifications you will have 2 or more users with the same operator (%s).', 16, 1, @operatorBarcode)
		end

    END
GO
PRINT N'Creating [ver].[Trigger_VersionId_SetVersionId_On_Insert]...';


GO
CREATE TRIGGER [ver].[Trigger_VersionId_SetVersionId_On_Insert]
    ON [ver].[Tables]
    FOR INSERT
AS
    BEGIN
        SET NoCount ON

		DECLARE @versionId INT;
		SELECT @versionId = MAX(Id) FROM [ver].[Version] 

		UPDATE t
		SET VersionId = @versionId
		FROM [ver].[Tables] t
		INNER JOIN INSERTED i ON t.[Schema] = i.[Schema] AND t.[Name] = i.[Name]
			WHERE t.VersionId IS NULL
    END
GO
PRINT N'Creating [layout].[vActiveLines]...';


GO
CREATE VIEW [layout].[vActiveLines]
AS
	select l.ID id, l.[Name] [name], l.[Description] [description], l.[Tags] tags, l.[TimeOut] [timeOut],
		l.LocationID locationID, loc.[Name] locationName, lc.capacity, lc.eolMachines
	from [layout].Line l
		left join [layout].[Location] loc on l.LocationID = loc.ID
		left join (
			select c.LineID,
				ROUND(SUM(w.HourCapacity) * 8 * 11 / 12, 0) capacity,
				COUNT(w.ID) eolMachines
			from layout.Cell c
				inner join layout.Workbench w on c.ID = w.CellID
			where w.EOL = 1
			group by c.LineID
		) lc on l.ID = lc.LineID
	where l.Deleted = 0
GO
PRINT N'Creating [layout].[vActiveMonitors]...';


GO
CREATE VIEW [layout].[vActiveMonitors]
AS
	select m.ID id, m.[Location] [location], m.[Description] [description], m.IPAddress ipAddress,
		m.LocationID locationID, loc.[Name] locationName, m.LineID lineID, l.[Name] lineName
	from [layout].[Monitor] m
		left join [layout].Line l on m.LineID = l.ID
		left join [layout].[Location] loc on m.LocationID = loc.ID
	where m.Deleted = 0
GO
PRINT N'Creating [layout].[vActivePartNumbers]...';


GO
CREATE VIEW [layout].[vActivePartNumbers]
AS
	select PartNumber, [Description], Routing
	from [layout].PartNumber
	where Deleted = 0
GO
PRINT N'Creating [log].[vProcedureLog]...';


GO
CREATE VIEW [log].[vProcedureLog]
AS 
	SELECT pl.[TimeStamp], p.[Name], pl.[ProfileID], pl.CustomParams, pl.XMLParam,
		pl.[Message], pl.[ErrorID], pl.[DboError], pl.[DevError], pl.[ID]
	FROM [log].ProcedureLog pl
		inner join [log].[Procedure] p on pl.ProcedureID = p.ID
GO
PRINT N'Creating [report].[vLine]...';


GO
CREATE VIEW [report].[vLine]
AS
	select ID LineID, case Deleted when 1 then N'[del]' + [Name] else [Name] end LineName, Deleted
	from [layout].[Line]
GO
PRINT N'Creating [report].[vShiftType]...';


GO
CREATE VIEW [report].[vShiftType]
AS
	select 'A' ShiftType, 'Schimbul A' ShiftTypeName
	union all
	select 'B' ShiftType, 'Schimbul B' ShiftTypeName
	union all
	select 'c' ShiftType, 'Schimbul C' ShiftTypeName
GO
PRINT N'Creating [dbo].[vShiftLog]...';


GO
CREATE VIEW [dbo].[vShiftLog]
AS
	select sl.ID id, sl.[Data] [data], sl.DataStart dataStart, slp.DataStart dataEnd,
		N'Schimb ' + sl.ShiftType + N' [' + CONVERT(nchar(5), sl.DataStart, 108) + N' - ' + CONVERT(nchar(5), slp.DataStart, 108) + N']' shiftName,
		sl.ShiftType shiftType, sl.LocationID locationID, l.[Name] [locationName]
	from dbo.ShiftLog sl
		left join dbo.ShiftLog slp on sl.ID = slp.PreviousShiftLogID
		left join layout.[Location] l on sl.LocationID = l.ID
GO
PRINT N'Creating [target].[vDaily]...';


GO
CREATE VIEW [target].[vDaily]
AS
	select sl.[Data], d.[Value], t.[Name] TargetType,
		d.Billboard,  l.[Name] Line, l.Tags,
		sl.DataStart ShiftDataStart, sl.ShiftName, sl.ShiftType,
		d.ID, d.LineID, d.ShiftLogID, d.TypeID, l.LocationID, xl.[Name] LocationName, 
		d.UpdateDate, d.UpdateUserID
	from [target].[Daily] d
		left join layout.Line l on d.LineID = l.ID
		left join dbo.vShiftLog sl on d.ShiftLogID = sl.ID
		left join [target].[Type] t on d.TypeID = t.ID
		left join layout.[Location] xl on sl.LocationID = xl.ID
GO
PRINT N'Creating [target].[vHourly]...';


GO
CREATE VIEW [target].[vHourly]
AS
	select h.[Hour], h.[Value] HourlyTarget, h.CumulativeValue HourlyCumulativeTarget,
		d.Billboard, l.[Name] Line, t.[Name] TargetType,
		sl.[Data] ShiftData, sl.DataStart ShiftDataStart, sl.ShiftType,
		DATEADD(HOUR, h.[Hour] - 1, sl.DataStart) HourStart,
		DATEADD(HOUR, h.[Hour], sl.DataStart) HourEnd, loc.[Name] [Location],
		h.ID, h.DailyID, d.ShiftLogID, d.LineID, d.TypeID, sl.LocationID,
		CONVERT(nchar(3), DATEADD(HOUR, h.[Hour] - 1, sl.DataStart), 108) + N'00 '
			+ CONVERT(nchar(3), DATEADD(HOUR, h.[Hour], sl.DataStart), 108) + N'00' HourInterval,
		h.UpdateDate, h.UpdateUserID
	from [target].[Hourly] h
		left join [target].[Daily] d on h.DailyID = d.ID
		left join dbo.ShiftLog sl on d.ShiftLogID = sl.ID
		left join [layout].Line l on d.LineID = l.ID
		left join [target].[Type] t on d.TypeID = t.ID
		left join [layout].[Location] loc on sl.LocationID = loc.ID
GO
PRINT N'Creating [report].[vDowntimeReason]...';


GO
CREATE VIEW [report].[vDowntimeReason]
AS
	select h.LineID, h.ShiftData, DAY(h.ShiftData) [Day], h.ShiftType, 
		 dd.Comment Reason, SUM(dd.Duration) Duration
	from dbo.DowntimeDetails dd
		inner join dbo.Downtime d on dd.DowntimeID = d.ID
		inner join [target].vHourly h on d.TargetHourlyID = h.ID
	group by h.LineID, h.ShiftData, h.ShiftType, dd.Comment
GO
PRINT N'Creating [global].[GetDate]...';


GO
CREATE FUNCTION [global].[GetDate]()
RETURNS [datetime]
AS
BEGIN
	return GETDATE()
END
GO
PRINT N'Creating [global].[NextMonday]...';


GO
CREATE FUNCTION [global].[NextMonday](@Date datetime)
RETURNS datetime
AS
BEGIN
	
	declare @rez datetime,
			@dateFirst int = @@DATEFIRST,
			@datePart int = DATEPART(DW, @Date)

	if @dateFirst = 7
		set @rez = DATEADD(day, DATEDIFF(day, 0, @Date), case @datePart when 1 then 1 else 9 - @datePart end)
	else if @dateFirst = 1
		set @rez = DATEADD(day, DATEDIFF(day, 0, @Date), 8 - DATEPART(DW, @Date))

	return @rez
END
GO
PRINT N'Creating [log].[GetProcedureID]...';


GO
CREATE FUNCTION [log].[GetProcedureID]
(
	@name nvarchar(max)
)
RETURNS tinyint
AS
BEGIN
	declare @id tinyint;

	select @id = ID from [log].[Procedure] p
	where p.Name = @name

	return @id
END
GO
PRINT N'Creating [users].[IsTokenValid]...';


GO
/*
* Checks if a token is valid. Returns 1 if the token exists.
*/
CREATE FUNCTION [users].[IsTokenValid]
(
	@token nvarchar(MAX)
)
RETURNS BIT
AS
BEGIN
	
	declare @valid bit = 0;
	--TODO: check if @profileId has rights to cancel
	SELECT @valid = 1
	FROM [users].[AccountToken]
	WHERE Token = @token 
	AND IsActive = 1
	return @valid;
END
GO
PRINT N'Creating [users].[TokenExpirationInSeconds]...';


GO
CREATE FUNCTION [users].[TokenExpirationInSeconds]()
RETURNS INT
AS
BEGIN
	RETURN 36000; -- 10 hours	
END
GO
PRINT N'Creating [users].[vLoggedInUsers]...';


GO
CREATE VIEW [users].[vLoggedInUsers]
	AS 
	select w.ID WorkbenchID, w.Name, w.TypeID, p.ID ProfileID, p.FirstName, p.LastName, p.Barcode, l.[Name] [Level], [global].[GetDate]() [now], at.LoginTime, at.LogoutTime, at.Expire, at.Token 
	from [layout].Workbench w
		inner join [layout].[WorkbenchStatus] ws on ws.WorkbenchID = w.ID
		inner join [users].[Profile] p on p.ID = ws.LoggedInProfileID
		inner join [users].[Level] l on l.ID = p.LevelID
		inner join [users].[Account] a on a.ProfileID = p.ID
		left join [users].[AccountToken] at on a.ID = at.AccountID
	where at.IsActive = 1
GO
PRINT N'Creating [layout].[DF_Order_DateIn]...';


GO
ALTER TABLE [layout].[WorkbenchStatus]
    ADD CONSTRAINT [DF_Order_DateIn] DEFAULT ([global].[GetDate]()) FOR [LastChanged];


GO
PRINT N'Creating [log].[DF_ProcedureLog_TimeStamp]...';


GO
ALTER TABLE [log].[ProcedureLog]
    ADD CONSTRAINT [DF_ProcedureLog_TimeStamp] DEFAULT ([global].[GetDate]()) FOR [TimeStamp];


GO
PRINT N'Creating [users].[DF_UserProfile_CreatedAt]...';


GO
ALTER TABLE [users].[Profile]
    ADD CONSTRAINT [DF_UserProfile_CreatedAt] DEFAULT (global.GetDate()) FOR [CreatedAt];


GO
PRINT N'Creating [users].[DF_Operator_CreateTimeStamp]...';


GO
ALTER TABLE [users].[Operator]
    ADD CONSTRAINT [DF_Operator_CreateTimeStamp] DEFAULT ([global].[GetDate]()) FOR [CreateTimeStamp];


GO
PRINT N'Creating [users].[DF_AccountToken_Expire]...';


GO
ALTER TABLE [users].[AccountToken]
    ADD CONSTRAINT [DF_AccountToken_Expire] DEFAULT (dateadd(minute,(60), [global].[GetDate]())) FOR [Expire];


GO
PRINT N'Creating [users].[DF_AccountToken_LoginTime]...';


GO
ALTER TABLE [users].[AccountToken]
    ADD CONSTRAINT [DF_AccountToken_LoginTime] DEFAULT ([global].[GetDate]()) FOR [LoginTime];


GO
PRINT N'Creating [users].[DF_Account_CreatedAt]...';


GO
ALTER TABLE [users].[Account]
    ADD CONSTRAINT [DF_Account_CreatedAt] DEFAULT ([global].[GetDate]()) FOR [CreatedAt];


GO
PRINT N'Creating [layout].[Trigger_WorkbenchStatus_Update_ErrorId]...';


GO
CREATE TRIGGER [layout].[Trigger_WorkbenchStatus_Update_ErrorId]
    ON [layout].[WorkbenchStatus]
    FOR INSERT, UPDATE
    AS
    BEGIN
        SET NoCount ON

		-- when errorId updates, we update the error timestamp. Errors will be shown only for a limited time based on this
		IF UPDATE(ErrorId)
		BEGIN
			update ws
			set HasErrorTimeStamp = [global].[GetDate](),
				LastChanged = [global].[GetDate]()
			from [layout].WorkbenchStatus ws
				inner join Error e on ws.ErrorId = e.ID
				inner join inserted on ws.WorkbenchID = inserted.WorkbenchID
		END
    END
GO
PRINT N'Creating [users].[Trigger_Account_UpdatedAt]...';


GO
CREATE TRIGGER [users].[Trigger_Account_UpdatedAt]
    ON [users].[Account]
    AFTER UPDATE
    AS
    BEGIN
        SET NoCount ON

		UPDATE a
        SET a.[UpdatedAt] = [global].[GetDate]()
		from [users].[Account] a
			inner join Inserted i on a.ID = i.ID

    END
GO
PRINT N'Starting rebuilding table [dbo].[BillboardLog]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_BillboardLog] (
    [TargetHourlyID]      INT            NOT NULL,
    [HourInterval]        NVARCHAR (50)  NOT NULL,
    [ActualAchieved]      SMALLINT       CONSTRAINT [DF_BillboardLog_ActualAchieved] DEFAULT 0 NOT NULL,
    [CumulativeAchieved]  SMALLINT       CONSTRAINT [DF_BillboardLog_CumulativeAchieved] DEFAULT 0 NOT NULL,
    [Defects]             SMALLINT       CONSTRAINT [DF_BillboardLog_Defects] DEFAULT 0 NOT NULL,
    [Downtime]            SMALLINT       CONSTRAINT [DF_BillboardLog_Downtime] DEFAULT 0 NOT NULL,
    [Comment]             NVARCHAR (100) NULL,
    [Escalated]           NVARCHAR (50)  NULL,
    [SignedOffOperatorID] INT            NULL,
    [UpdateDate]          DATETIME       CONSTRAINT [DF_BillboardLog_UpdateDate] DEFAULT [global].[GetDate]() NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_BillboardLog1] PRIMARY KEY CLUSTERED ([TargetHourlyID] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[BillboardLog])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_BillboardLog] ([TargetHourlyID], [HourInterval], [ActualAchieved], [Defects], [Downtime], [Comment], [Escalated], [SignedOffOperatorID], [UpdateDate])
        SELECT   [TargetHourlyID],
                 [HourInterval],
                 [ActualAchieved],
                 [Defects],
                 [Downtime],
                 [Comment],
                 [Escalated],
                 [SignedOffOperatorID],
                 [UpdateDate]
        FROM     [dbo].[BillboardLog]
        ORDER BY [TargetHourlyID] ASC;
    END

DROP TABLE [dbo].[BillboardLog];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_BillboardLog]', N'BillboardLog';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PK_BillboardLog1]', N'PK_BillboardLog', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating [dbo].[FK_Billboard_TargetHourly]...';


GO
ALTER TABLE [dbo].[BillboardLog] WITH NOCHECK
    ADD CONSTRAINT [FK_Billboard_TargetHourly] FOREIGN KEY ([TargetHourlyID]) REFERENCES [target].[Hourly] ([ID]);


GO
PRINT N'Creating [dbo].[CK_BillboardLog_ActualAchieved]...';


GO
ALTER TABLE [dbo].[BillboardLog] WITH NOCHECK
    ADD CONSTRAINT [CK_BillboardLog_ActualAchieved] CHECK ([ActualAchieved] >= (0));


GO
PRINT N'Creating [dbo].[CK_BillboardLog_CumulativeAchieved]...';


GO
ALTER TABLE [dbo].[BillboardLog] WITH NOCHECK
    ADD CONSTRAINT [CK_BillboardLog_CumulativeAchieved] CHECK ([CumulativeAchieved] >= [ActualAchieved]);


GO
PRINT N'Creating [dbo].[CK_BillboardLog_Defects]...';


GO
ALTER TABLE [dbo].[BillboardLog] WITH NOCHECK
    ADD CONSTRAINT [CK_BillboardLog_Defects] CHECK ([Defects] >= (0));


GO
PRINT N'Creating [dbo].[CK_BillboardLog_Downtime]...';


GO
ALTER TABLE [dbo].[BillboardLog] WITH NOCHECK
    ADD CONSTRAINT [CK_BillboardLog_Downtime] CHECK ([Downtime] >= (0));


GO
PRINT N'Creating [dbo].[FK_Billboard_SignedOffOperator]...';


GO
ALTER TABLE [dbo].[BillboardLog] WITH NOCHECK
    ADD CONSTRAINT [FK_Billboard_SignedOffOperator] FOREIGN KEY ([SignedOffOperatorID]) REFERENCES [users].[Operator] ([ID]);


GO
PRINT N'Creating [report].[vMonth]...';


GO
CREATE VIEW [report].[vMonth]
AS
	select CONVERT(varchar(7), h.ShiftData, 121) [Month],
		MIN(h.ShiftData) DataStart,
		MAX(h.ShiftData) DataEnd
	from dbo.BillboardLog bl
		inner join [target].vHourly h on bl.TargetHourlyID = h.ID
	group by CONVERT(varchar(7), h.ShiftData, 121)
GO
PRINT N'Creating [dbo].[vBillboardLog]...';


GO
CREATE VIEW [dbo].[vBillboardLog]
AS
	select bl.HourInterval, h.[Hour], h.HourStart, h.HourEnd,
		h.[HourlyTarget] [Target], h.HourlyCumulativeTarget CumulativeTarget,
		bl.ActualAchieved, bl.CumulativeAchieved,
		bl.Defects, bl.Downtime, bl.Comment, bl.Escalated,
		o.Barcode SignedOffOperatorBarcode, o.FirstName + N' ' + o.LastName SignedOffOperator,
		sl.[Data] ShiftData, sl.DataStart ShiftDataStart, l.[Name] Line, loc.[Name] [Location] ,
		bl.TargetHourlyID, h.DailyID TargetDailyID, bl.SignedOffOperatorID,
		sl.ID ShiftLogID, sl.ShiftType, d.LineID
	from dbo.BillboardLog bl
		left join [target].[vHourly] h on bl.TargetHourlyID = h.ID
		left join [target].[Daily] d on h.DailyID = d.ID
		left join [dbo].[ShiftLog] sl on d.ShiftLogID = sl.ID
		left join [layout].[Line] l on d.LineID = l.ID
		left join [layout].[Location] loc on sl.LocationID = loc.ID
		left join [users].[Operator] o on bl.SignedOffOperatorID = o.ID
GO
PRINT N'Creating [dbo].[DownTime_TotalDuration_InsertUpdateDelete]...';


GO

CREATE TRIGGER [dbo].[DownTime_TotalDuration_InsertUpdateDelete]
    ON [dbo].[Downtime]
    FOR DELETE, INSERT, UPDATE
    AS
    BEGIN
        SET NoCount ON

		update bl
		set Downtime += i.Duration
		from dbo.BillboardLog bl
			inner join (
				select TargetHourlyID, SUM(DATEDIFF(MINUTE, DataStart, DataEnd)) Duration
				from Inserted
				group by TargetHourlyID
			) i on bl.TargetHourlyID = i.TargetHourlyID

		update bl
		set Downtime -= d.Duration
		from dbo.BillboardLog bl
			inner join (
				select TargetHourlyID, SUM(DATEDIFF(MINUTE, DataStart, DataEnd)) Duration
				from Deleted
				group by TargetHourlyID
			) d on bl.TargetHourlyID = d.TargetHourlyID
    END
GO
PRINT N'Creating [report].[vActualsVsTargetAndNotOK]...';


GO
CREATE VIEW [report].[vActualsVsTargetAndNotOK]
AS
	select LineID, ShiftData, DAY(ShiftData) [Day], ShiftType,
		MAX(CumulativeTarget) [Target],
		MAX(CumulativeAchieved) Achieved,
		SUM(Defects) NOK
	from dbo.vBillboardLog
	group by LineID, ShiftData, ShiftType
GO
PRINT N'Altering [ver].[MarkVersion]...';


GO
/*
	Author/Date	:	Marian Brostean, 04.03.2017
	Description	:	Start or finish version increase
	LastChange	:	
*/
ALTER PROCEDURE [ver].[MarkVersion]
	@buildNumber INT,
	@fullVersion NVARCHAR(8) = null,
	@description NVARCHAR(MAX) = null,
	@start BIT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @exists INT = 0;
	SELECT @exists = count(1) from [ver].[Version] where [Id] = @buildNumber

	IF (@start = 1)
	BEGIN
		IF (@exists <> 0) 
		BEGIN
			RAISERROR('Version already exists!', 16, 1)
			RETURN (-1)
		END

		-- Insert statements for procedure here
		INSERT INTO [ver].[Version]
			([Id],
			[Version],
			[VersionDescription],
			[DateStarted])
		VALUES
			(@buildNumber,
			@fullVersion,
			@description,	
			getDate());
	END
	ELSE
	BEGIN
		IF (@exists = 0) 
		BEGIN
			RAISERROR('Version does not exist!', 16, 1)
			RETURN (-1)
		END

		UPDATE [ver].[Version]
		SET DateEnded = getdate()
		WHERE [Id] = @buildNumber
	END
	RETURN (0);
END
GO
PRINT N'Creating [global].[TraceError]...';


GO
/*
	Author/Date	:	Cristian Dinu, 03.08.2018
	Description	:	Global procedure for save error in ProcedureLog table
	LastChange	:	
*/

CREATE PROCEDURE [global].[TraceError]
	@ErrorNumber	int,
	@ErrorMessage	nvarchar(MAX),
	@ProcedureLogID	bigint,
	@ReturnError	int OUTPUT
as
	set @ReturnError = -1
	if @@TRANCOUNT = 0
			update [log].ProcedureLog set DboError = @ErrorNumber, DevError = @ErrorMessage where ID = @ProcedureLogID

	-- all stored procedures use begin try ... catch model for manage errors
	-- so raiserror should be activate, except the case that calling procedures is the the outer (the first one)
	-- because no exception (raiserror) should be activated to Marian application (only return < 0)
	if @@NESTLEVEL > 2 raiserror(@ErrorMessage, 16, 1)

	-- search for any return parameter in error message string
	-- custom error messages (ID's from Error table) can be passed to Marian application by return value of exec sp (negative values)
	declare @i int
	set @i = CHARINDEX(N'[return=', @ErrorMessage, 1) + 8
	if @i <> 8	set @ReturnError = - CONVERT(int, SUBSTRING(@ErrorMessage, @i, CHARINDEX(N']', @ErrorMessage, @i) - @i))

return(0)
GO
PRINT N'Creating [global].[CheckObjectID]...';


GO
/*
	Author/Date	:	Cristian Dinu, 03.08.2018
	Description	:	global procedure, check any object ID
	LastChange	:	
*/

CREATE PROCEDURE [global].[CheckObjectID]
	@ObjectSchema		nvarchar(50) = 'dbo',
	@ObjectTable		nvarchar(50),
	@ObjectColumnID		nvarchar(50) = N'ID',
	@ObjectID			nvarchar(50),
	@CheckIsNull		bit = 1,
	@ProcedureLogID		bigint
as
	declare @errorNumber	int = 16,
			@errorMessage	nvarchar(max),
			@cmdSql			nvarchar(max),
			@isObsolete		bit,
			@isActive		bit

	begin try
		-- check if ObjectName is NULL
		if @ObjectTable is NULL goto ObjectTableIsNull

		-- check if ObjectID is NULL
		if @CheckIsNull = 1 and @ObjectID is NULL goto ObjectIDisNull

		-- check if @ObjectID is valid
		set @cmdSql = N'select @ObjectID = [' + @ObjectColumnID + N'] from [' + @ObjectSchema + N'].[' + @ObjectTable + N'] where [' + @ObjectColumnID + N'] = ''' + @ObjectID + N''''
		exec [dbo].[sp_executesql] @cmdSql, N'@ObjectID nvarchar(50) OUTPUT', @ObjectID OUTPUT
		if @@ROWCOUNT = 0 goto ObjectIDisMissing
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  N'SQL string command ''' + @cmdSql + N''' was executed with errors. Check if @ObjectTable value ([' + @ObjectSchema + '].[' + @ObjectTable + N']) has a corresponding database table. Original error message: ' + ERROR_MESSAGE()
		goto ErrorExit
	end catch
	
return(0)

ObjectTableIsNull:
	set @errorMessage = N'[DevError]Search ID in table [' + @ObjectSchema + N'].[' + @ObjectTable + N'] failed: @ObjectTable is NULL.'
	goto ErrorExit
ObjectIDisNull:
	set @errorMessage = N'[DevError]Search ID in table [' + @ObjectSchema + N'].[' + @ObjectTable + N'] failed: @ObjectID is NULL.'
	goto ErrorExit
ObjectIDisMissing:
	set @errorMessage = N'[DevError] ' + @ObjectColumnID + N'=' + @ObjectID + N' is missing in [' + @ObjectSchema + N'].[' + @ObjectTable + N'] table.'
	goto ErrorExit
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @ProcedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [global].[CheckObjectBarcode]...';


GO
/*
	Author/Date	:	Cristian Dinu, 03.08.2018
	Description	:	global procedure, check any object barcode and return ID
	LastChange	:	
*/

CREATE PROCEDURE [global].[CheckObjectBarcode]
	@ObjectSchema			nvarchar(50) = 'dbo',
	@ObjectTable			nvarchar(50),
	@ObjectColumnBarcode	nvarchar(50) = N'Barcode',
	@ObjectBarcode			nvarchar(50),
	@CheckIsNull			bit = 1,
	@ProcedureLogID			bigint,
	@ObjectID				bigint OUTPUT
as
	declare @errorNumber	int = 16,
			@errorMessage	nvarchar(max),
			@cmdSql			nvarchar(max),
			@isObsolete		bit,
			@isActive		bit

	begin try
		-- check if ObjectName is NULL
		if @ObjectTable is NULL goto ObjectTableIsNull

		-- check if ObjectNarcode is NULL
		if @CheckIsNull = 1 and @ObjectBarcode is NULL goto ObjectBarcodeIsNull

		-- check if @ObjectID is valid
		set @cmdSql = N'select @ObjectID = ID from [' + @ObjectSchema + '].[' + @ObjectTable + N'] where ' + @ObjectColumnBarcode + N' = ''' + @ObjectBarcode + ''''
		exec [dbo].[sp_executesql] @cmdSql, N'@ObjectBarcode nvarchar(50), @ObjectID bigint OUTPUT', @ObjectBarcode, @ObjectID OUTPUT
		if @@ROWCOUNT = 0 goto ObjectIDisMissing
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  N'SQL string command ''' + @cmdSql + N''' was executed with errors. Check if @ObjectTable value ([' + @ObjectSchema + '].[' + @ObjectTable + N']) has a corresponding database table. Original error message: ' + ERROR_MESSAGE()
		goto ErrorExit
	end catch
	
return(0)

ObjectTableIsNull:
	set @errorMessage = N'[DevError]@ObjectTable is NULL.'
	goto ErrorExit
ObjectBarcodeIsNull:
	set @errorMessage = N'[DevError]@ObjectBarcode is NULL.'
	goto ErrorExit
ObjectIDisMissing:
	set @errorMessage = N'[DevError] ''' + @ObjectColumnBarcode + N' = ''' + @ObjectBarcode + N''' is missing in [' + @ObjectSchema + N'].[' + @ObjectTable + N'] table.'
	goto ErrorExit
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @ProcedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [layout].[DeleteMonitor]...';


GO
/*
	Author/Date	:	Cristian Dinu, 19.08.2018
	Description	:	delete monitor record
	LastChange	:	
*/

CREATE PROCEDURE [layout].[DeleteMonitor]
	@UserID			int,
	@MonitorID		int,
	@ErrorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, CustomParams)
	values(10, @UserID,
		N'@MonitorID=' + CONVERT(nvarchar(10), @MonitorID))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Monitor', @ObjectID = @MonitorID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		update layout.Monitor
		set Deleted = 1
		where ID = @MonitorID

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @ErrorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [layout].[EditMonitor]...';


GO
/*
	Author/Date	:	Cristian Dinu, 19.08.2018
	Description	:	modify monitor record
	LastChange	:	
*/

CREATE PROCEDURE [layout].[EditMonitor]
	@UserID			int,
	@MonitorID		int,
	@Location		nvarchar(50),
	@Description	nvarchar(255),
	@IPAddress		nvarchar(50),
	@LocationID		char(2),
	@LineID			smallint,
	@ErrorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, CustomParams)
	values(9, @UserID,
		N'@MonitorID=' + CONVERT(nvarchar(10), @MonitorID) + N', ' +
		N'@Location=' + @Location + N', ' +
		N'@Description=' + @Description + N', ' +
		N'@IPAddress=' + @IPAddress + N', ' +
		N'@LocationID=' + @LocationID + N', ' +
		N'@LineID=' + CONVERT(nvarchar(10), @LineID))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Monitor', @ObjectID = @MonitorID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Location', @ObjectID = @LocationID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @LineID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		update layout.Monitor
		set [Location] = @Location, 
			[Description] = @Description,
			IPAddress = @IPAddress,
			LocationID = @LocationID,
			LineID = @LineID
		where ID = @MonitorID

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @ErrorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [layout].[AddMonitor]...';


GO
/*
	Author/Date	:	Cristian Dinu, 19.08.2018
	Description	:	add a new monitor
	LastChange	:	
*/

CREATE PROCEDURE [layout].[AddMonitor]
	@UserID			int,
	@Location		nvarchar(50),
	@Description	nvarchar(255),
	@IPAddress		nvarchar(50),
	@LocationID		char(2),
	@LineID			smallint,
	@ErrorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, CustomParams)
	values(8, @UserID,
		N'@Location=' + @Location + N', ' +
		N'@Description=' + @Description + N', ' +
		N'@IPAddress=' + @IPAddress + N', ' +
		N'@LocationID=' + @LocationID + N', ' +
		N'@LineID=' + CONVERT(nvarchar(10), @LineID))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Location', @ObjectID = @LocationID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @LineID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		insert into layout.Monitor([Location], [Description], IPAddress, LocationID, LineID)
		values(@Location, @Description, @IPAddress, @LocationID, @LineID)

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @ErrorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [log].[LogError]...';


GO
CREATE PROCEDURE [log].[LogError]
	@procedureId tinyint,
	@message nvarchar(4000),
	@errorId int = null,
	@dboError int = null,
	@devError nvarchar(4000) = null
AS
	set nocount on

	insert into [log].ProcedureLog
		(ProcedureID, [Message], ErrorID, DevError, DboError)
	values
		(@procedureId, @message, @errorId, @devError, @dboError)
RETURN 0
GO
PRINT N'Creating [report].[DowntimeReason]...';


GO
/*
	Author/Date	:	Cristian Dinu, 09.10.2018
	Description	:	downtime reasons report
	LastChange	:
*/
CREATE PROCEDURE [report].[DowntimeReason]
	@LineID			int,		-- mandatoru
	@ShiftType		char(1),	-- optional
	@DateStart		datetime,	-- mandatory
	@DateEnd		datetime	-- mahdatory
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(26, N'@LineID=' + CONVERT(nvarchar(10), @LineID) + N','
				+ N'@ShiftType' + @ShiftType
				+ N'@DateStart=' + CONVERT(nvarchar(10), @DateStart, 121) + N','
				+ N'@DateEnd=' + CONVERT(nvarchar(10), @DateEnd, 121))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @LineID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		select h.LineID, h.ShiftType, h.ShiftData, DAY(h.ShiftData) [Day],
			 dd.Comment Reason, SUM(dd.Duration) Duration
		from dbo.DowntimeDetails dd
			inner join dbo.Downtime d on dd.DowntimeID = d.ID
			inner join [target].vHourly h on d.TargetHourlyID = h.ID
		where LineID = @LineID
			and (ShiftType = @ShiftType or @ShiftType is NULL)
			and ShiftData between @DateStart and @DateEnd
		group by h.LineID, h.ShiftType, h.ShiftData, dd.Comment
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [report].[ActualsVsTargetAndNotOK]...';


GO
/*
	Author/Date	:	Cristian Dinu, 09.10.2018
	Description	:	actuals vs target & notOK report
	LastChange	:
*/
CREATE PROCEDURE [report].[ActualsVsTargetAndNotOK]
	@LineID			int,		-- mandatoru
	@ShiftType		char(1),	-- optional
	@DateStart		datetime,	-- mandatory
	@DateEnd		datetime	-- mahdatory
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(25, N'@LineID=' + CONVERT(nvarchar(10), @LineID) + N','
				+ N'@ShiftType' + @ShiftType
				+ N'@DateStart=' + CONVERT(nvarchar(10), @DateStart, 121) + N','
				+ N'@DateEnd=' + CONVERT(nvarchar(10), @DateEnd, 121))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @LineID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- report data
		select LineID, ShiftType, ShiftData, DAY(ShiftData) [Day],
			MAX(CumulativeTarget) [Target],
			MAX(CumulativeAchieved) Achieved,
			SUM(Defects) NOK
		from dbo.vBillboardLog
		where LineID = @LineID
			and (ShiftType = @ShiftType or @ShiftType is NULL)
			and ShiftData between @DateStart and @DateEnd
		group by LineID, ShiftType, ShiftData
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [report].[HistoricalShift]...';


GO
/*
	Author/Date	:	Cristian Dinu, 08.10.2018
	Description	:	get historical billboard data
	LastChange	:
*/
CREATE PROCEDURE [report].[HistoricalShift]
	@LineID			int,		-- mandatory
	@Date			datetime,	-- mandatory
	@ShiftType		char(1),	-- mandatory
	@XML			XML				OUTPUT,
	@ErrorMessage	nvarchar(MAX)	OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(24, N'@LineID=' + CONVERT(nvarchar(10), @LineID) + N','
				+ N'@Date=' + CONVERT(nvarchar(10), @Date, 121) + N','
				+ N'@ShiftType' + @ShiftType)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @LineID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		-- check if selected Line/Date/ShiftType is signedoff
		select @ErrorMessage = N'Specified shift is not yet signed off. See monitors list'
		from dbo.ShiftLogSignOff slso
			inner join dbo.ShiftLog sl on slso.ShiftLogID = sl.ID
		where slso.LineID = @LineID
			and sl.[Data] = @date
			and sl.ShiftType = @ShiftType
			and slso.SignedOffOperatorID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		set @XML = (
			select top 1
				CONVERT(nvarchar(10), d.[data], 20) 'date', d.ShiftName 'shift',
				l.[Name] 'lineName', d.LocationName 'locationName',
				CONVERT(decimal(6,2), ROUND((
					select CONVERT(decimal(10,2), MAX(CumulativeAchieved)) /
						CONVERT(decimal(10,2), case 
							when MAX(HourEnd) < [global].[GetDate]() then 440
							when MIN(HourStart) = [global].[GetDate]() then 1
							else DATEDIFF(MINUTE, MIN([HourStart]), [global].[GetDate]()) / 12 * 11
						end)
					from dbo.vBillboardLog
					where TargetDailyID = d.ID
				), 2)) 'deliveryTime',
				(
					select MAX(ActualAchieved)
					from dbo.vBillboardLog
					where TargetDailyID = d.ID
				) 'maxHourProduction',
				o.FirstName + N' ' + o.LastName 'shiftSignOff',
				(select
					(select	bl.TargetHourlyID '@id',
						bl.HourInterval 'hourInterval', bl.[Target] 'target', bl.CumulativeTarget 'cumulativeTarget',
						bl.ActualAchieved 'achieved', bl.CumulativeAchieved 'cumulativeAchieved', bl.Defects 'defects',
						bl.Downtime 'downtime', bl.Comment 'comment', bl.Escalated 'escalated', bl.SignedOffOperator 'signoff'
					from dbo.vBillboardLog bl
						inner join [target].vHourly h on bl.TargetHourlyID = h.ID
					where bl.TargetDailyID = d.ID
					order by bl.[Hour]
					for xml path('hour'), type, elements XSINIL)
				for xml path('hours'), type)
			from layout.Line l
				inner join [target].vDaily d on l.ID = d.LineID
				inner join dbo.ShiftLogSignOff slso on d.LineID = slso.LineID and d.ShiftLogID = slso.ShiftLogID
				INNER JOIN [users].Operator o on slso.SignedOffOperatorID = o.ID
			where l.ID = @LineID
				and d.ShiftType = @ShiftType
				and d.[Data] = @Date
				and d.Billboard = 1
			for xml path('billboard'), type)
		if @XML is NULL goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @xml
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @ErrorMessage = N'There are no results data for specified filtering conditions'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [users].[GetProfileIdFromToken]...';


GO
-- Selects the user profile id (in "id") of the user being authenticated with @token
CREATE PROCEDURE [users].[GetProfileIdFromToken]
	@token nvarchar(MAX)
AS
	SET NOCOUNT ON

	declare @userProfileId bigint = -1;

	select		@userProfileId = ua.ProfileID
    from		[users].AccountToken uat 
    inner join	Account ua on uat.AccountID = ua.ID
    WHERE		Token = @token

	if (@userProfileId is null) return -1;
	return @userProfileId;
GO
PRINT N'Creating [users].[RegisterUserFromOperator]...';


GO
CREATE PROCEDURE [users].[RegisterUserFromOperator]
	@operatorId int,
	@password nvarchar(50)
AS
	set nocount on;
	
	if (not exists ( select 1 from [users].[Operator] op where op.ID = @operatorId)) goto Error_OperatorNotFound;

	declare @existingOperators int;
	select @existingOperators = count(1) from Profile where ISNULL(OperatorID, 0) = @operatorId;

	if (@existingOperators <> 0) goto Error_ProfileExists;
	begin try
		begin tran
		insert into [users].[Profile] (Deleted, Barcode, FirstName, LastName, LevelID, IsActive, OperatorID)
		select 0, op.Barcode, op.FirstName, op.LastName, 1 /* lowest security level*/, 1, op.ID
		from [users].[Operator] op
		where op.ID = @operatorId

		declare @profileId int;
		select @profileId = SCOPE_IDENTITY();

		insert into [users].[Account] (Deleted, Username, [Password], AccountProviderUniqueAppID, AccountProviderID, ProfileID)
		select 0, op.Barcode, @password, N'', 1, @profileId
		from [users].[Operator] op
		where op.ID = @operatorId

		commit tran
	end try
	begin catch
		if (@@TRANCOUNT > 0) rollback tran;
		Return -412; -- some error occured RegisterUser_InternalError
	end catch
RETURN 0
Error_CannotCreateProfile:
	return -442;
Error_ProfileExists:
	return -443;
Error_OperatorNotFound:
	return -444;
GO
PRINT N'Creating [users].[InsertOrUpdateToken]...';


GO
CREATE PROCEDURE [users].[InsertOrUpdateToken]
	@token nvarchar(MAX),
	@userAccountId int,
	@workbenchId int
AS
	SET NOCOUNT ON

	if (@userAccountId is null) return -1;

	declare @expireDelta int; -- seconds to keep the token alive
	declare @expireDate datetime;

	select @expireDelta = cast (s.[Value] as int) 
	from [global].[Setting] s
	where s.[Key] = 'AUTH_TOKEN_EXPIRES_IN_SECONDS';

	set @expireDate = DATEADD(SECOND, @expireDelta, [global].[GetDate]())

	update [users].AccountToken 
	set Expire = @expireDate
	where Token = @token;

	if @@rowcount = 0
	begin
		INSERT INTO [users].AccountToken(AccountID, Token, Expire, WorkbenchID) VALUES(@userAccountId, @token, @expireDate, @workbenchId);
	end
RETURN 1
GO
PRINT N'Creating [users].[ForceLogoutIfTokensHaveExpired]...';


GO
CREATE PROCEDURE [users].[ForceLogoutIfTokensHaveExpired]
AS
	set nocount on;
	declare @token nvarchar(MAX) = null;
	declare @errorNumber int = 0;

	declare @tokensTable table (Token nvarchar(MAX), WorkbenchID int);

	begin try
		begin tran
		insert into @tokensTable
		select Token, WorkbenchID
		from [users].AccountToken act
		where ((act.IsActive = 1) or (act.LogoutTime is null))
			and act.Expire < [global].[GetDate]()

		update act
		set IsActive = 0,
			LogoutTime = [global].[GetDate](),
			AutomaticLogout = 1
		from [users].AccountToken act
			inner join @tokensTable t on t.Token = act.Token 

		update wbs
		set LoggedInProfileID = null
		from [layout].[WorkbenchStatus] wbs
			inner join @tokensTable t on wbs.WorkbenchID = t.WorkbenchID
		commit tran
	end try
	begin catch
		if (@@TRANCOUNT > 0) rollback tran;
		set @errorNumber = -1;
	end catch

RETURN @errorNumber;
GO
PRINT N'Creating [users].[DeleteUser]...';


GO
CREATE PROCEDURE [users].[DeleteUser]
	@profileId bigint
AS
	set nocount on;

	BEGIN TRY
		BEGIN TRAN
		declare @deleteProfileSucceeded bit = 1;
		declare @deleteAccountSucceeded bit = 1;
		update [users].[Profile]
		set Deleted = 1, IsActive = 0
		where ID = @profileId;
		if (@@ROWCOUNT > 0) SET @deleteProfileSucceeded = 1;

		update [users].[Account]
		set Deleted = 1
		where ProfileID = @profileId;
		if (@@ROWCOUNT > 0) SET @deleteAccountSucceeded = 1;
		if ((@deleteAccountSucceeded = 0) and (@deleteProfileSucceeded = 0))
		BEGIN
			ROLLBACK TRAN;
			RETURN -2; -- something is wrong with the profile, could not delete, or it's already deleted
		END

		COMMIT TRAN
	END TRY
	BEGIN CATCH
		IF (@@TRANCOUNT > 0) ROLLBACK TRAN;
		PRINT ERROR_MESSAGE();
		RETURN -1;
	END CATCH
return 0
GO
PRINT N'Creating [users].[ClearExpiredTokens]...';


GO
/*
	Deletes all the authentication tokens which have expired.
	You can call this periodically or when a user attempts to login
*/
CREATE PROCEDURE [users].[ClearExpiredTokens]
AS
	SET NOCOUNT ON

	update [users].AccountToken 
	set IsActive = 0
	WHERE Expire < [global].[GetDate]()

RETURN 0
GO
PRINT N'Creating [users].[ChangePasswordForProfile]...';


GO
CREATE PROCEDURE [users].[ChangePasswordForProfile]
	@profileId bigint,
	@newPassword nvarchar(50)
AS
	set nocount on;

	if(@profileId is null) goto Error_ProfileNotFound;

	update		[users].[Account]
	set			[Password] = @newPassword
	where		ProfileID = @profileId;

	if (@@ROWCOUNT = 0) goto Error_AccountNotFound;

RETURN 0;
Error_AccountNotFound:
	return -403;
Error_ProfileNotFound:
	return -404;
GO
PRINT N'Creating [users].[ChangeMyPassword]...';


GO
CREATE PROCEDURE [users].[ChangeMyPassword]
	@token nvarchar(MAX),
	@newPassword nvarchar(50)
AS
	set nocount on;

	declare @profileId bigint;
	exec @profileId = [users].[GetProfileIdFromToken] @token = @token;

	declare @result int;
	exec @result = [users].[ChangePasswordForProfile] @profileId = @profileId, @newPassword = @newPassword
return @result;
GO
PRINT N'Creating [users].[AddUser]...';


GO
-- TODO: create trigger instead of procedure
CREATE PROCEDURE [users].[AddUser]
	@firstname NVARCHAR(255),
	@lastname NVARCHAR(255),
	@levelId SMALLINT,
	@username NVARCHAR(50),
	@password NVARCHAR(50)
AS
	
    SET NOCOUNT ON
	DECLARE @result BIT = 0;
    BEGIN TRY
        BEGIN TRAN
        DECLARE @profileId INT

        INSERT INTO [users].[Profile](FirstName, LastName, LevelID, CreatedAt, IsActive, Barcode)
        VALUES (@firstname, @lastname, @levelId, [global].[GetDate](), 1, @username)

        SELECT @profileId = SCOPE_IDENTITY()

        INSERT INTO [users].[Account](ProfileID, [Username], [Password], AccountProviderID, AccountProviderUniqueAppID, CreatedAt)
        VALUES (@profileId, @username, @password, 1, 0, [global].[GetDate]())

        SET @result = 1;
        COMMIT TRAN
    END TRY
    BEGIN CATCH
		IF (@@TRANCOUNT > 0) ROLLBACK TRAN;
        SET @result = 0;
    END CATCH

RETURN @result
GO
PRINT N'Creating [users].[LoginOnWorkbench]...';


GO
/*
 *  Checks if an operator with the given credentials exist (barcode = username, password = password)
 *  Logs in the operator on the given workbench
 *		NOTE: if the operator is already logged in on another workbench, he gets automatically logged out
 *	Creates an account token for the profile
 *	Returns the account token and the profileId if successful
 *	It tries repeatedly to generate a unique token. If it fails, it returns an error.

	pseudocode
 	#1 validate input params
	#2 find the account by barcode and password
	#3 force logout if tokens have expired (set LogoutTime = [global].[GetDate](), IsActive = 0, LoggedInProfileId in WBStatus on null)
	#4 throw error if user is already logged in on another workbench
	#5 do the login

 *
 * @param: @barcode	- operator barcode as displayed on the badge
 * @param: @password - md5 encrypted password
 * @param: @workbenchId - target workbench where to login
 */
CREATE PROCEDURE [users].[LoginOnWorkbench]
	@barcode nvarchar(50),
	@password nvarchar(50),
	@workbenchId int = null,
	@token nvarchar(MAX) OUTPUT,
	@profileId int OUTPUT
AS
	set nocount on;
	declare @errorNumber int = 0;
 	--#1 validate input params

	-- basic checks for username and password
	if (ltrim(rtrim(@barcode)) = N'') goto Error_UsernameEmpty;
	if (ltrim(rtrim(@password)) = N'') goto Error_PasswordEmpty;

	set @token = null;
	set @profileId = 0;
	
	declare @workbenchExists bit = 0;
	select @workbenchExists = 1 from [layout].Workbench where ID = @workbenchId or (@workbenchId is null);
	if (@workbenchExists = 0) goto Error_WorkbenchDoesNotExist;

	begin try
		declare @userAccountId int;

		select		@userAccountId = a.ID, @profileId = a.ProfileID 
		from		[users].Account a
		inner join	[users].Profile p on a.ProfileID = p.ID
		where		ISNULL(a.[Username], '') = @barcode 
					and ISNULL(a.[Password], '') = @password 
					and a.[AccountProviderID] = 1 -- TrueHR
					and ISNULL(p.IsActive, 0) = 1

		if ((@userAccountId is null) or (@profileId is null) or (@workbenchId is null)) 
		begin 
			set @errorNumber = -441; 
			goto Error_Other; 
		end -- throw 50441, N'Error_WrongCredentials', 1;	
	
		-- #3 force logout if tokens have expired (set LogoutTime = [global].[GetDate](), IsActive = 0, LoggedInProfileId in WBStatus on null)
		exec [users].[ForceLogoutIfTokensHaveExpired];
		
		-- #4 throw error if user is already logged in on another workbench
		-- look up user on other workbenches (this workbench is excluded)
		declare @currentWorkbenchId int;
		select @currentWorkbenchId = wb.ID
		from [layout].[Workbench] wb
		inner join [layout].[WorkbenchStatus] wbs on wbs.WorkbenchID = wb.ID
		where ISNULL(wbs.LoggedInProfileID, 0) = @profileId and (wb.ID <> @workbenchId)

		-- user is logged in elsewhere, throw error
		if (@currentWorkbenchId is not null)
		begin 
			set @errorNumber = -551; 
			goto Error_Other; 
		end  --throw 50551, N'Error_UserLoggedInOnOtherWorkbench', 1;

		-- #5 do the login
		-- check if there is another user logged in on the worbench except myself

		DECLARE @loggedInUser BIGINT
		SELECT @loggedInUser = LoggedInProfileID FROM [layout].WorkbenchStatus where WorkbenchID = @workbenchId and ISNULL(LoggedInProfileID, 0) <> @profileId
		IF @loggedInUser is not null
		begin 
			set @errorNumber = -554; 
			goto Error_Other; 
		end 	--throw 50554, N'Login_OtherUserAlreadyLoggedInOnWorkbench', 1;

		begin tran
		-- login operator on @workbenchId
		update [layout].[WorkbenchStatus]
		set LoggedInProfileID = @profileId
		where [layout].[WorkbenchStatus].WorkbenchID = @workbenchId

		-- create a new account token for the user
		SET @token = convert(nvarchar(MAX), newid())
		exec [users].InsertOrUpdateToken @token = @token, @userAccountId = @userAccountId, @workbenchId = @workbenchId;
		commit tran
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER();
		declare @error nvarchar(4000);
		set @error = N'[' + ERROR_PROCEDURE() + N']' + ERROR_MESSAGE()

		declare @procedureId tinyint = [log].[GetProcedureID]('[Users].[LoginWithOperatorBarcode]');
		exec [log].LogError @procedureId = @procedureId, @errorId = 1, @message = @error, @devError = 'internal error login on workbench';
		goto Error;
	end catch
		
RETURN 0;
Error:
	if (@@TRANCOUNT > 0) rollback tran;
Error_Other:
	return @errorNumber;
Error_UsernameEmpty:
	return -408;
Error_PasswordEmpty:
	return -409;
Error_WorkbenchDoesNotExist:
	return -516;
Error_UserLoggedInOnOtherWorkbench:
	return -551;
GO
PRINT N'Creating [users].[GetWorkerUserLevels]...';


GO
/*
*  Returns profile fields given a profileId
*  @param: @profileId
*/
CREATE PROCEDURE [users].[GetWorkerUserLevels]
	@userProfileId bigint
AS
	SET NOCOUNT ON

	if (@userProfileId is null) return -1;

	select		ID, Name
    from		[users].[Level]
    WHERE		ID in (
		1,		--WarehouseManager
		2,		--Driver
		3)		--Operator
	return 1;
GO
PRINT N'Creating [users].[GetProfileFromId]...';


GO
/*
*  Returns profile fields given a profileId
*  @param: @profileId
*/
CREATE PROCEDURE [users].[GetProfileFromId]
	@userProfileId bigint
AS
	SET NOCOUNT ON

	select		FirstName, LastName, LevelID, Barcode
    from		[users].[Profile]
    where		ID = @userProfileId

	if (@userProfileId is null) return -1;
return @userProfileId;
GO
PRINT N'Creating [users].[SaveRights]...';


GO
/*
	Author/Date	:	Cristian Dinu, 03.08.2018
	Description	:	process edited feature rights
	LastChange	:	
*/

CREATE PROCEDURE [users].[SaveRights]
	@UserID	int,
	@XML	XML
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@requestorLevelID	smallint,
			@timeStamp			datetime
	declare @txml table(
					ID					varchar(250) NOT NULL,
					TargetLevelID		smallint NOT NULL,
					NewValue			bit NOT NULL,
					OldValue			bit NOT NULL,
					RequestorLevelID	smallint,
					UpdateUserID		int,
					UpdateDate			datetime)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, XMLParam)
	values(2, @UserID, @XML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get user security level
		select @requestorLevelID = LevelID
		from users.[Profile]
		where ID = @UserID

		-- get info from XML
		insert into @txml(ID, TargetLevelID, NewValue, OldValue, RequestorLevelID, UpdateUserID, UpdateDate)
		select txml.ID, txml.LevelID, txml.NewValue,
			case when f.Operation is NULL then 0 else 1 end New_Value, f.RequestorLevelID, f.UpdateUserID, f.UpdateDate
		from (
			select
				'hourly-sign-off' as ID,
				T.[Right].value('@levelID', 'smallint') as LevelID,
				T.[Right].value('hourly-sign-off[1]', 'bit') as NewValue
			from @xml.nodes('/root/rights/right') as T([Right])

			union all

			select
				'shift-sign-off' as ID,
				T.[Right].value('@levelID', 'smallint') as LevelID,
				T.[Right].value('shift-sign-off[1]', 'bit')	as NewValue
			from @xml.nodes('/root/rights/right') as T([Right])
		) txml
			left join users.Feature f on txml.ID = f.ID and txml.LevelID = f.TargetLevelID
		if @@ROWCOUNT = 0 goto EmptyXML

		select @timeStamp = CONVERT(datetime, T.[Right].value('.', 'char(23)'), 121)
		from @xml.nodes('/root/timeStamp') as T([Right])
		if @@ROWCOUNT = 0 goto WrongXML

		-- checking zone
		-- if exist recent feature updates, after XML timestamp
		select @errorMessage = N'During current edit session another user (' + p.FirstName + ' ' + p.LastName + ') started user rights changes'
		from @txml t
			inner join users.[Profile] p on t.UpdateUserID = p.ID
		where t.UpdateDate is not NULL 
			and t.UpdateDate > @timeStamp
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if requestor security level is lower than target level, except admin
		if @requestorLevelID <> 1
		begin
			select @errorMessage = N'Current rights can be changed only for lower security level than requestor'
			from @txml
			where NewValue <> OldValue 
				and TargetLevelID < @requestorLevelID
			if @@ROWCOUNT <> 0 goto ErrorExit
		end

		-- if user has no rights to change current rights setting
		select @errorMessage = N'Security level for requestor user is lower than target security level ('
			+ p.FirstName + ' ' + p.LastName + '[' + l.[Name] + '])'
		from @txml t
			inner join users.[Profile] p on t.UpdateUserID = p.ID
			inner join users.[Level] l on p.LevelID = l.ID
		where t.NewValue <> t.OldValue 
			and t.RequestorLevelID is not NULL
			and t.RequestorLevelID < @requestorLevelID
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- data updates zone
		-- there is only insert & update table record because Operation = NULL means no right
		-- insert rights
		begin tran
			insert into users.Feature(ID, RequestorLevelID, TargetLevelID, Operation, UpdateUserID, UpdateDate)
			select t.ID, @requestorLevelID, t.TargetLevelID, case t.NewValue when 1 then 'X' end, @UserID, [global].[GetDate]()
			from @txml t
				left join users.Feature f on t.ID = f.ID and t.TargetLevelID = f.TargetLevelID
			where t.NewValue <> t.OldValue
				and f.ID is NULL

			-- update rigths
			update f
			set Operation = case t.NewValue when 1 then 'X' else NULL end,
				UpdateUserID = @UserID,
				UpdateDate = [global].[GetDate]()
			from users.Feature f
				inner join @txml t on f.ID = t.ID and f.TargetLevelID = t.TargetLevelID
			where t.NewValue <> t.OldValue
		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[BillboardHourSignOff]...';


GO
/*
	Author/Date	:	Cristian Dinu, 23.08.2018
	Description	:	close billboard hour by sign off
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[BillboardHourSignOff]
	@TargetHourlyID		int,
	@OperatorBarcode	nvarchar(50),
	@ErrorMessage		nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint,
			@operatorID			int,
			@hourInterval		nvarchar(50),
			@signedOff			bit = 0

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(14,
		N'@TargetHourlyID=' + ISNULL(CONVERT(nvarchar(10), @TargetHourlyID), N'NULL') + N', ' +
		N'@OperatorBarcode=' + ISNULL(@OperatorBarcode, N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'dbo', @ObjectTable = N'BillboardLog', @ObjectColumnID = N'TargetHourlyID', @ObjectID = @TargetHourlyID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectBarcode @ObjectSchema = N'users', @ObjectTable = N'Operator', @ObjectBarcode = @OperatorBarcode, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID, @ObjectID = @operatorID OUTPUT

		-- check if sign off moment is after hour interval end
		if EXISTS(
			select TargetHourlyID
			from dbo.vBillboardLog
			where TargetHourlyID = @TargetHourlyID
				and [global].[GetDate]() between HourStart and HourEnd
		) goto HourInProgress

		-- check if there is any other previous unsigned off BillbordLog record 
		select @hourInterval = bl0.HourInterval,
				@signedOff = bl.SignedOffOperatorBarcode
		from dbo.vBillboardLog bl
			left join dbo.vBillboardLog bl0 on bl.TargetDailyID = bl0.TargetDailyID and bl.[Hour] > bl0.[Hour] and bl0.SignedOffOperator is NULL
		where bl.TargetHourlyID = @TargetHourlyID
		if @hourInterval is not NULL goto MissingSignedOffHourInterval
		if @signedOff is not NULL goto AlreadySignedOffHourInterval

		update dbo.BillboardLog
		set [SignedOffOperatorID] = @operatorID,
			[UpdateDate] = [global].[GetDate]()
		where TargetHourlyID = @TargetHourlyID

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @ErrorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

HourInProgress:
	set @ErrorMessage =  N'You cannot sign off the current hour interval until is not finished.'
	goto ErrorExit
MissingSignedOffHourInterval:
	set @ErrorMessage =  N'There is at least one previous opened hour interval (e.g. ' + @hourInterval + N'), therefore you can not sign off current interval.'
	goto ErrorExit
AlreadySignedOffHourInterval:
	set @ErrorMessage =  N'Current hour interval is already signed off.'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[BillboardSaveComment]...';


GO
/*
	Author/Date	:	Cristian Dinu, 21.08.2018
	Description	:	save comment on billboard hourly row
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[BillboardSaveComment]
	@TargetHourlyID	int,
	@Comment		nvarchar(100),
	@ErrorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint,
			@signedOff			int

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(12,
		N'@TargetHourlyID=' + ISNULL(CONVERT(nvarchar(10), @TargetHourlyID), N'NULL') + N', ' +
		N'@Comment=' + ISNULL(@Comment, N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'dbo', @ObjectTable = N'BillboardLog', @ObjectColumnID = N'TargetHourlyID', @ObjectID = @TargetHourlyID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		if @Comment is NULL goto CommentNull

		-- check if BillbordLog record is already signed off
		select @signedOff = SignedOffOperatorID
		from dbo.BillboardLog
		where TargetHourlyID = @TargetHourlyID
		if @signedOff is not NULL goto AlreadySignedOffHourInterval
			
		update dbo.BillboardLog
		set [Comment] = @Comment,
			[UpdateDate] = [global].[GetDate]()
		where TargetHourlyID = @TargetHourlyID

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @ErrorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

CommentNull:
	set @ErrorMessage = 'Comment is NULL'
	goto ErrorExit
AlreadySignedOffHourInterval:
	set @ErrorMessage =  N'Current hour interval is already signed off, therefore no change can be made.'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[BillboardSaveEscalated]...';


GO
/*
	Author/Date	:	Cristian Dinu, 23.08.2018
	Description	:	save escalated on billboard hourly row
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[BillboardSaveEscalated]
	@TargetHourlyID	int,
	@Escalated		nvarchar(50),
	@ErrorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint,
			@signedOff			int

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(13,
		N'@TargetHourlyID=' + ISNULL(CONVERT(nvarchar(10), @TargetHourlyID), N'NULL') + N', ' +
		N'@Escalated=' + ISNULL(@Escalated, N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'dbo', @ObjectTable = N'BillboardLog', @ObjectColumnID = N'TargetHourlyID', @ObjectID = @TargetHourlyID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		if @Escalated is NULL goto EscalatedNull

		-- check if BillbordLog record is already signed off
		select @signedOff = SignedOffOperatorID
		from dbo.BillboardLog
		where TargetHourlyID = @TargetHourlyID
		if @signedOff is not NULL goto AlreadySignedOffHourInterval
			
		update dbo.BillboardLog
		set [Escalated] = @Escalated,
			[UpdateDate] = [global].[GetDate]()
		where TargetHourlyID = @TargetHourlyID

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @ErrorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EscalatedNull:
	set @ErrorMessage = 'Escalated is NULL'
	goto ErrorExit
AlreadySignedOffHourInterval:
	set @ErrorMessage =  N'Current hour interval is already signed off, therefore no change can be made.'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[BillboardShiftSignOff]...';


GO
/*
	Author/Date	:	Cristian Dinu, 23.08.2018
	Description	:	close billboard shift by sign off
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[BillboardShiftSignOff]
	@shiftLogSignOffID	int,
	@OperatorBarcode	nvarchar(50),
	@ErrorMessage		nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint,
			@operatorID			int,
			@shift				nvarchar(50),
			@signedOff			int

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(15,
		N'@shiftLogSignOffID=' + ISNULL(CONVERT(nvarchar(10), @shiftLogSignOffID), N'NULL') + N', ' +
		N'@OperatorBarcode=' + ISNULL(@OperatorBarcode, N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'dbo', @ObjectTable = N'ShiftLogSignOff', @ObjectID = @shiftLogSignOffID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectBarcode @ObjectSchema = N'users', @ObjectTable = N'Operator', @ObjectBarcode = @OperatorBarcode, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID, @ObjectID = @operatorID OUTPUT

		-- check if sign off moment is after shift end
		if EXISTS(
			select slso.id
			from dbo.ShiftLogSignOff slso
				inner join dbo.vShiftLog sl on slso.ShiftLogID = sl.ID
			where slso.ID = @shiftLogSignOffID
				and [global].[GetDate]() < sl.dataEnd
		) goto ShiftInProgress

		-- check if there is any other previous unsigned off BillbordLog record 
		select	@shift = slso0.ShiftName,
				@signedOff = slso.SignedOffOperatorID
		from dbo.ShiftLogSignOff slso
			inner join dbo.ShiftLog sl on slso.ShiftLogID = sl.ID
			left join (
				select sl.locationID, slso.LineID, sl.dataStart, sl.shiftName
				from dbo.ShiftLogSignOff slso
					inner join dbo.vShiftLog sl on slso.ShiftLogID = sl.ID
				where slso.SignedOffOperatorID is NULL
			) slso0 on sl.LocationID = slso0.locationID and slso.LineID = slso0.LineID and sl.[DataStart] > slso0.[dataStart]
		where slso.ID = @shiftLogSignOffID
		if @shift is not NULL goto MissingSignedOffShift
		if @signedOff is not NULL goto AlreadySignedOffShift

		update dbo.ShiftLogSignOff
		set [SignedOffOperatorID] = @operatorID,
			[UpdateDate] = [global].[GetDate]()
		where ID = @shiftLogSignOffID

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @ErrorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

ShiftInProgress:
	set @ErrorMessage =  N'You cannot sign off the current shift until is not finished.'
	goto ErrorExit
MissingSignedOffShift:
	set @ErrorMessage =  N'There is at least one previous opened shift on same location (e.g. ' + @shift + N'), therefore current shift can not be signed off .'
	goto ErrorExit
AlreadySignedOffShift:
	set @ErrorMessage =  N'Current shift is already signed off.'
	goto ErrorExit
MissingSignOffInfo:
	set @ErrorMessage =  N'Missing ShiftLogSignOff record.'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @ErrorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[GetBillboard]...';


GO
/*
	Author/Date	:	Cristian Dinu, 07.08.2018
	Description	:	get billboard data
	LastChange	:
*/

CREATE PROCEDURE [dbo].[GetBillboard]
	@MonitorID	int,
	@XML	XML	OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(11, N'@MonitorID=' + CONVERT(nvarchar(10), @MonitorID))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Monitor', @ObjectID = @MonitorID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		set @XML = (
			select top 1
				CONVERT(nvarchar(10), sl.[data], 20) 'date', sl.shiftName 'shift',
				l.[Name] 'lineName', sl.locationName 'locationName',
				CONVERT(decimal(6,2), ROUND((
					select CONVERT(decimal(10,2), MAX(CumulativeAchieved)) /
						CONVERT(decimal(10,2), case 
							when MAX(HourEnd) < [global].[GetDate]() then 440
							when MIN(HourStart) = [global].[GetDate]() then 1
							else DATEDIFF(MINUTE, MIN([HourStart]), [global].[GetDate]()) / 12 * 11
						end)
					from dbo.vBillboardLog
					where TargetDailyID = d.ID
				), 2)) 'deliveryTime',
				(
					select MAX(ActualAchieved)
					from dbo.vBillboardLog
					where TargetDailyID = d.ID
				) 'maxHourProduction',
				(select slso.ID '@shiftLogSignOffID',
					(select	bl.TargetHourlyID '@id',
						case when bl.SignedOffOperatorID is not NULL then 'yes' end '@closed',
						case when bl.[Hour] = fo.[Hour] then 'yes' end '@firstOpen',
						bl.HourInterval 'hourInterval', bl.[Target] 'target', bl.CumulativeTarget 'cumulativeTarget',
						bl.ActualAchieved 'achieved', bl.CumulativeAchieved 'cumulativeAchieved', bl.Defects 'defects',
						bl.Downtime 'downtime', bl.Comment 'comment', bl.Escalated 'escalated', bl.SignedOffOperatorbarcode 'signoff'
					from dbo.vBillboardLog bl
						inner join [target].vHourly h on bl.TargetHourlyID = h.ID
						left join (
							select LineID, ShiftLogID, MIN([Hour]) [Hour]
							from dbo.vBillboardLog
							where SignedOffOperatorID is NULL
							group by LineID, ShiftLogID
						) fo on bl.LineID = fo.LineID and bl.ShiftLogID = fo.ShiftLogID
					where bl.TargetDailyID = d.ID
					order by bl.[Hour]
					for xml path('hour'), type, elements XSINIL)
				for xml path('hours'), type)
			from layout.Monitor m
				inner join layout.Line l on m.LineID = l.ID
				inner join [target].Daily d on l.ID = d.LineID
				inner join dbo.vShiftLog sl on d.ShiftLogID = sl.id
				inner join dbo.ShiftLogSignOff slso on d.LineID = slso.LineID and d.ShiftLogID = slso.ShiftLogID
			where m.ID = @MonitorID
				and slso.SignedOffOperatorID is NULL
			order by sl.dataStart
			for xml path('billboard'), type)
		if @XML is NULL goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @xml
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[GetDowntime]...';


GO
/*
	Author/Date	:	Cristian Dinu, 25.08.2018
	Description	:	get downtime intervals
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[GetDowntime]
	@TargetHourlyID	int,
	@XML			XML	OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(16, N'@targetHourlyID=' + CONVERT(nvarchar(10), @TargetHourlyID))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectTable = N'BillboardLog', @ObjectColumnID = N'TargetHourlyID', @ObjectID = @TargetHourlyID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		set @XML = (
			select CONVERT(nvarchar(10), ShiftData, 120) + N' ' + REPLACE(HourInterval, N' ', N'-') 'forDate', (
				select d.ID '@id', w.[Name] 'machine',
					CONVERT(nchar(5), d.DataStart, 108) + N' ' + CONVERT(nchar(5), d.DataEnd, 108) 'timeInterval',
					DATEDIFF(MINUTE, d.DataStart, d.DataEnd) 'totalDuration',
					(select ID '@id', CONVERT(char(24), UpdateDate, 121) '@timeStamp', 
						Comment 'comment', Duration 'duration'
					from dbo.DowntimeDetails
					where DowntimeID = d.ID
					order by d.DataStart
					for xml path('reason'), root('reasons'), type)
				from dbo.Downtime d
					inner join layout.Workbench w on d.WorkbenchID = w.ID
				where d.TargetHourlyID = @TargetHourlyID
				for xml path('row'), type)
			from dbo.vBillboardLog
			where TargetHourlyID = @TargetHourlyID
			for xml path(''), root('root')) 
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @xml
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[SaveBreaks]...';


GO
/*
	Author/Date	:	Cristian Dinu, 10.08.2018
	Description	:	process edited shift breaks
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[SaveBreaks]
	@UserID			int,
	@XML			XML,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint,
			@timeStamp			datetime,
			@nextMonday			datetime = [global].NextMonday([global].[GetDate]())
	declare @txml table(
					[ID]				smallint NOT NULL IDENTITY(1,1),
					LocationID			char(2),
					ShiftLogID			int,
					TimeStart			datetime,
					ShiftType			char(1),
					[From]				char(5),
					[To]				char(5),
					NewTimeStart		datetime,
					NewTimeEnd			datetime)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, XMLParam)
	values(4, @UserID, @XML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get info from XML
		insert into @txml(LocationID, ShiftLogID, TimeStart, ShiftType, [From], [To])
		select
			T.[Break].value('../../@location', 'char(2)') as LocationID,
			T.[Break].value('../@shiftLogID', 'int') as ShiftLogID,
			CONVERT(datetime, T.[Break].value('@timeStart', 'char(16)'), 121) as TimeStart,
			T.[Break].value('../@name', 'char(1)') as ShiftType,
			T.[Break].value('from[1]', 'char(5)') as [From],
			T.[Break].value('to[1]', 'char(5)') as [To]
		from @XML.nodes('//break') as T([Break])

		select @timeStamp = CONVERT(datetime, T.[Break].value('.', 'char(23)'), 121)
		from @XML.nodes('/root/timeStamp') as T([Break])
		if @@ROWCOUNT = 0 goto WrongXML

		-- checking zone
		-- if exist recent feature updates, after XML timestamp
		select top 1 @errorMessage = N'During current edit session another user started breaks changes'
		from dbo.ShiftLogBreak
		where UpdateDate > @timeStamp
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if there are empty fields
		select top 1 @errorMessage = N'There are records with missing LocationID values'
		from @txml
		where LocationID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing ShiftType values'
		from @txml
		where ShiftType is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing From values'
		from @txml
		where [From] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing To values'
		from @txml
		where [To] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if LocationID is correct
		select top 1 @errorMessage = N'There are records with incorrect LocationID values (e.g. ' + LocationID + N')'
		from @txml
		where LocationID not in (select ID from layout.[Location])
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if ShiftType is correct
		select top 1 @errorMessage = N'There are records with incorrect ShiftType values (e.g. ' + ShiftType + N')'
		from @txml
		where ShiftType not like '[A-C]'
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if From and To time value are correct
		select top 1 @errorMessage = N'There are records with From values that are not in time format (e.g. [' + [From] + N'])'
		from @txml
		where [From] not like '[0-2][0-9]:[0-5][0-9]'
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with incorrect From values (e.g. ' + [From] + N')'
		from @txml
		where ISDATE(CONCAT(CONVERT(char(11), @nextMonday, 121), [From])) = 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with To values that are not in time format (e.g. [' + [From] + N'])'
		from @txml
		where [From] not like '[0-2][0-9]:[0-5][0-9]'
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with incorrect To values (e.g. ' + [From] + N')'
		from @txml
		where ISDATE(CONCAT(CONVERT(char(11), @nextMonday, 121), [To])) = 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if TimeStart and TimeEnd are between shift limits
		update t
		set NewTimeStart = case 
							when CONVERT(char(5), sl.DataStart, 114) < t.[From]
								then CONVERT(datetime, CONCAT(CONVERT(char(11), sl.Data, 121), t.[From]), 121)
							else CONVERT(datetime, CONCAT(CONVERT(char(11), DATEADD(day, 1, sl.Data), 121), t.[From]), 121) end,
			NewTimeEnd = case 
							when CONVERT(char(5), sl.DataStart, 114) < t.[To]
								then CONVERT(datetime, CONCAT(CONVERT(char(11), sl.Data, 121), t.[To]), 121)
							else CONVERT(datetime, CONCAT(CONVERT(char(11), DATEADD(day, 1, sl.Data), 121), t.[To]), 121) end
		from @txml t
			inner join dbo.ShiftLog sl on t.ShiftType = sl.ShiftType
		where sl.Data = @nextMonday

		select top 1 @errorMessage = N'There are records with break start time outside shift limits (e.g. for shift ' + t.ShiftType + N' break starts from ' + t.[From] + N')'
		from @txml t
			inner join dbo.ShiftLog sl on t.ShiftType = sl.ShiftType
			inner join dbo.ShiftLog slp on sl.ID = slp.PreviousShiftLogID
		where sl.Data = @nextMonday
			and (t.NewTimeStart < sl.DataStart or t.NewTimeStart >= slp.DataStart )
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with break end time outside shift limits (e.g. for shift ' + t.ShiftType + N' break ends at ' + t.[To] + N')'
		from @txml t
			inner join dbo.ShiftLog sl on t.ShiftType = sl.ShiftType
			inner join dbo.ShiftLog slp on sl.ID = slp.PreviousShiftLogID
		where sl.Data = @nextMonday
			and (t.NewTimeEnd < sl.DataStart or t.NewTimeEnd >= slp.DataStart )
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if From < To
		select top 1 @errorMessage = N'There are records with incorrect break time limits (e.g. for shift ' + ShiftType + N' break between ' + [From] + N' , ' + [To] + N')'
		from @txml
		where NewTimeStart > NewTimeEnd
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check breaks overlapping
		select top 1 @errorMessage = N'There are breaks overlapping (e.g. for shift ' + _t1.ShiftType + N' break [' + _t1.[From] + N' , ' + _t1.[To] + N'] and break [' + _t2.[From] + N' , ' + _t2.[To] + N'])'
		from @txml _t1
			inner join @txml _t2 on _t1.ShiftLogID = _t2.ShiftLogID
		where _t1.ID <> _t2.ID and
			(_t2.NewTimeStart between _t1.NewTimeStart and _t1.NewTimeEnd
			or _t2.NewTimeEnd between _t1.NewTimeStart and _t1.NewTimeEnd)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- total break time during shifts <> 40 min
		select top 1 @errorMessage = N'There is at least one shift with total breaks time different than 40 minutes (e.g. shift ' + ShiftType + N')'
		from @txml
		group by ShiftType
		having SUM(DATEDIFF(MINUTE, NewTimeStart, NewTimeEnd)) <> 40
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- data updates zone
		begin tran
			-- deleted removed breaks
			delete slb
			from dbo.ShiftLogBreak slb
				inner join dbo.ShiftLog sl on slb.ShiftLogID = sl.ID
				inner join (
					select sl.ShiftType, DATEDIFF(MINUTE, sl.DataStart, slb.TimeStart) Diff
					from dbo.ShiftLogBreak slb
						inner join dbo.ShiftLog sl on slb.ShiftLogID = sl.ID
						left join @txml t on slb.ShiftLogID = t.ShiftLogID and slb.TimeStart = t.TimeStart
					where t.ShiftLogID is NULL
						and sl.Data = @nextMonday
				) d on sl.ShiftType = d.ShiftType and DATEDIFF(MINUTE, sl.DataStart, slb.TimeStart) = d.Diff
			where sl.Data >= @nextMonday
				
			-- insert new breaks
			insert into dbo.ShiftLogBreak(ShiftLogID, TimeStart, TimeEnd, UpdateDate)
			select sl.ID, DATEADD(MINUTE, i.DiffStart, sl.DataStart), DATEADD(MINUTE, i.DiffEnd, sl.DataStart), [global].[GetDate]()
			from dbo.ShiftLog sl
				inner join (
					select t.ShiftType, DATEDIFF(MINUTE, sl.DataStart, t.NewTimeStart) DiffStart, DATEDIFF(MINUTE, sl.DataStart, t.NewTimeEnd) DiffEnd
					from @txml t
						inner join dbo.ShiftLog sl on t.ShiftType = sl.ShiftType
					where t.TimeStart is NULL
						and sl.Data = @nextMonday
				) i on sl.ShiftType = i.ShiftType
			where sl.Data >= @nextMonday

			-- update breaks
			update slb
			set TimeStart = DATEADD(MINUTE, u.DiffStart, sl.DataStart),
				TimeEnd = DATEADD(MINUTE, u.DiffEnd, sl.DataStart),
				UpdateDate = [global].[GetDate]()
			from dbo.ShiftLogBreak slb
				inner join dbo.ShiftLog sl on slb.ShiftLogID = sl.ID
				inner join (
					select sl.ShiftType,
						DATEDIFF(MINUTE, sl.DataStart, t.TimeStart) Diff,
						DATEDIFF(MINUTE, sl.DataStart, t.NewTimeStart) DiffStart,
						DATEDIFF(MINUTE, sl.DataStart, t.NewTimeEnd) DiffEnd
					from dbo.ShiftLogBreak slb
						inner join dbo.ShiftLog sl on slb.ShiftLogID = sl.ID
						inner join @txml t on slb.ShiftLogID = t.ShiftLogID and slb.TimeStart = t.TimeStart
					where sl.Data = @nextMonday
						and (slb.TimeStart <> t.NewTimeStart or slb.TimeEnd <> t.NewTimeEnd)
				) u on sl.ShiftType = u.ShiftType and DATEDIFF(MINUTE, sl.DataStart, slb.TimeStart) = u.Diff
			where sl.Data >= @nextMonday
		if @@TRANCOUNT > 0 commit tran
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[SaveDowntime]...';


GO
/*
	Author/Date	:	Cristian Dinu, 10.08.2018
	Description	:	process edited downtime details
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[SaveDowntime]
	@TargetHourlyID int,
	@XML			XML,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint
	declare @txml table(
					ID			int,
					DowntimeID	int,
					Comment		nvarchar(100),
					Duration	smallint,
					[TimeStamp]	datetime)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, XMLParam)
	values(17, @XML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectTable = N'BillboardLog', @ObjectColumnID = N'TargetHourlyID', @ObjectID = @TargetHourlyID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get info from XML
		insert into @txml(ID, DowntimeID, Comment, Duration, [TimeStamp])
		select
			T.[Downtime].value('@id', 'int') as [ID],
			T.[Downtime].value('../../@id', 'int') as [DowntimeID],
			T.[Downtime].value('comment[1]', 'nvarchar(100)') as [Comment],
			T.[Downtime].value('duration[1]', 'smallint') as [Duration],
			CONVERT(datetime, T.[Downtime].value('@timeStamp', 'char(23)'), 121) as [TimeStamp]
		from @xml.nodes('//reason') as T([Downtime])

		-- checking zone
		-- if exist recent updates, after XML timestamp
		select top 1 @errorMessage = N'During current edit session another user started downtime details changes'
		from @txml
		where [TimeStamp] < (
			select MAX(dd.UpdateDate)
			from dbo.DowntimeDetails dd
				inner join dbo.Downtime d on dd.DowntimeID = d.ID
			where d.TargetHourlyID = @TargetHourlyID)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if there are empty fields
		select top 1 @errorMessage = N'There are records with missing DowntimeID values'
		from @txml
		where DowntimeID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Comment values'
		from @txml
		where Comment is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Duration values'
		from @txml
		where Duration is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if ID is correct
		select top 1 @errorMessage = N'There are records with incorrect DowntimeDetailsID values (e.g. ' + CONVERT(nvarchar(10), _t.ID) + N')'
		from @txml _t
			left join dbo.DowntimeDetails dd on _t.ID = dd.ID
			left join dbo.Downtime d on dd.DowntimeID = d.ID and d.TargetHourlyID = @TargetHourlyID
		where _t.ID is not NULL
			and d.ID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if DowntimeID is correct
		select top 1 @errorMessage = N'There are records with incorrect DowntimeID values (e.g. ' + CONVERT(nvarchar(10), DowntimeID) + N')'
		from @txml
		where DowntimeID not in (select ID from dbo.Downtime)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Duration is correct
		select top 1 @errorMessage = N'There are records with negative Duration values (e.g. ' + CONVERT(nvarchar(10), Duration) + N')'
		from @txml
		where Duration < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Duration is correct
		select top 1 @errorMessage = N'There are records with incorrect Duration values, greater than downtime interval (' + CONVERT(nvarchar(10), Duration) + N' minutes)'
		from @txml _t
			inner join dbo.Downtime d on _t.DowntimeID = d.ID
		where _t.Duration > DATEDIFF(MINUTE, d.DataStart, d.DataEnd)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- total duration <= downtime interval
		select top 1 @errorMessage = N'Total reasons duration (' + CONVERT(nvarchar(10), SUM(_t.Duration))
			+ N'min) is different than downtime total duration (' + CONVERT(nvarchar(10), DATEDIFF(MINUTE, d.DataStart, d.DataEnd)) + N'min)'
		from @txml _t
			inner join dbo.Downtime d on _t.DowntimeID = d.ID
		group by _t.DowntimeID, d.DataStart, d.DataEnd
		having SUM(_t.Duration) <> DATEDIFF(MINUTE, d.DataStart, d.DataEnd)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- data updates zone
		begin tran
			-- delete removed downtime details
			delete dd
			from dbo.DowntimeDetails dd
				inner join dbo.Downtime d on dd.DowntimeID = d.ID
			where d.TargetHourlyID = @TargetHourlyID
				and dd.ID not in (select ID from @txml)
				
			-- insert new downtime details
			insert into dbo.DowntimeDetails(DowntimeID, Comment, Duration, UpdateDate)
			select DowntimeID, Comment, Duration, [global].[GetDate]()
			from @txml
			where ID is NULL

			-- update downtime details
			update dd
			set Comment = _t.Comment,
				Duration = _t.Duration,
				UpdateDate = [global].[GetDate]()
			from dbo.DowntimeDetails dd
				inner join @txml _t on dd.ID = _t.ID
		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[uspGetErrorInfo]...';


GO
CREATE PROCEDURE uspGetErrorInfo  
AS  
SELECT  
    ERROR_NUMBER() AS ErrorNumber  
    ,ERROR_SEVERITY() AS ErrorSeverity  
    ,ERROR_STATE() AS ErrorState  
    ,ERROR_PROCEDURE() AS ErrorProcedure  
    ,ERROR_LINE() AS ErrorLine  
    ,ERROR_MESSAGE() AS ErrorMessage;
GO
PRINT N'Creating [target].[SetBillboardOnByIDList]...';


GO
CREATE PROCEDURE [target].[SetBillboardOnByIDList]
	@UserID		int,
	@DailyIDs	idTable READONLY
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@customParams		varchar(MAX) = N'@DailyIDs=',
			@id					int = 0
	declare @daily table(ID int, TypeID char(2), LineID int, ShiftLogID int, BillboardDailyID int, ShiftIsOpen bit )

	-- log procedure exec
	while 1=1
	begin
		select top 1 
			@customParams += CONVERT(varchar(10), ID) + N';',
			@id = ID
		from @DailyIDs
		where ID > @id
		order by ID
		if @@ROWCOUNT = 0 break
	end

	insert into [log].ProcedureLog(ProcedureID, ProfileID, CustomParams)
	values(23, @UserID, @customParams)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		-- there is no need for that, sp is executed by other sp

		-- take info from plannnig dataset
		insert into @daily(ID, TypeID, LineID, ShiftLogID, BillboardDailyID, ShiftIsOpen)
		select d.ID, d.TypeID, d.LineID, d.ShiftLogID, db.ID, case when slso.SignedOffOperatorID is NULL then 1 else 0 end
		from [target].vDaily d0
			inner join [target].vDaily d on d0.TypeID = d.TypeID and d0.LineID = d.LineID and d0.[Data] = d.[Data]
			left join dbo.ShiftLogSignOff slso on d.LineID = slso.LineID and d.ShiftLogID = slso.ShiftLogID
			left join [target].Daily db on d.LineID = db.LineID and d.ShiftLogID = db.ShiftLogID and db.Billboard = 1
		where d0.ID in (select ID from @DailyIDs)
		-- check if dataset is already BillBoardOn
		if EXISTS(select ID from @daily where ID = BillboardDailyID) goto AlreadyBillboardOn
		-- check if corresponding shifts are open
		if EXISTS(select ID from @daily where ShiftIsOpen = 0) goto ClosedShifts
		
		-- data updates zone
		-- transction is not necessary, is already started from sp that call this

		-- previous dataset with same LineID + Data combination and BillboardOn should be set off
		update d
		set Billboard = 0
		from @daily _d
			inner join [target].Daily d on _d.TypeID <> d.TypeID and _d.LineID = d.LineID and _d.ShiftLogID = d.ShiftLogID
		where d.Billboard = 1

		-- set current planning dataset with BillboardOn
		update [target].Daily
		set Billboard = 1
		where ID in (select ID from @daily)

		-- update billboard planning values
		-- if BillboardLog is already set with previous planning dataset
		update bl
		set TargetHourlyID = hb.ID, UpdateDate = [global].[GetDate]()
		from @daily _d
			inner join [target].Hourly h on _d.BillboardDailyID = h.DailyID
			inner join dbo.BillboardLog bl on h.ID = bl.TargetHourlyID
			inner join [target].Hourly hb on _d.ID = hb.DailyID and h.[Hour] = hb.[Hour]

		-- if BillboardLog is empty insert new values
		insert into dbo.BillboardLog(TargetHourlyID, HourInterval)
		select ID, HourInterval
		from [target].vHourly
		where DailyID in (select ID from @daily where BillboardDailyID is NULL)

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

AlreadyBillboardOn:
	set @errorMessage = N'Planning data set is already set on Billboard'
	goto ErrorExit
ClosedShifts:
	set @errorMessage = N'Planning data set cannot be set on Billboard because it has at least on shift closed'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[SetOnBillboard]...';


GO
CREATE PROCEDURE [target].[SetOnBillboard]
	@UserID			int,
	@DailyTargetID	int,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint,
			@dailyIDs			idTable

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, CustomParams)
	values(22, @UserID,
		N'@DailyTargetID=' + ISNULL(CONVERT(nvarchar(10), @DailyTargetID), N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].CheckObjectID @ObjectSchema = N'target', @ObjectTable = N'Daily', @ObjectID = @DailyTargetID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		
		-- data updates zone
		begin tran
			insert into @dailyIDs values(@DailyTargetID)
			exec [target].[SetBillboardOnByIDList] @UserID = @UserID, @DailyIDs = @dailyIDs
		if @@TRANCOUNT > 0 commit tran
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [global].[GetSettingKeyValue]...';


GO
/*
	Author/Date	:	Cristian Dinu, 03.08.2018
	Description	:	global procedure, check any object ID
	LastChange	:	
*/

CREATE PROCEDURE [global].[GetSettingKeyValue]
	@Key				nvarchar(50),
	@ProcedureLogID		bigint,
	@Value				nvarchar(MAX) OUTPUT
AS
	declare	@errorMessage nvarchar(max)

	if @Key is NULL goto KeyIsNull
	
	select @Value = [Value] from [global].Setting where [Key] = @Key
	if @@ROWCOUNT = 0 goto MissingSettingKey

return(0)

KeyIsNull:
	set @errorMessage = N'[DevError]@Key is NULL.'
	goto ErrorExit
MissingSettingKey:
	set @errorMessage = N'[DevError]Miising value for setting key ' + @Key
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = 16, @ErrorMessage = @errorMessage, @ProcedureLogID = @ProcedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [layout].[GetProductionLines]...';


GO
/*
	Author/Date	:	Cristian Dinu, 07.08.2018
	Description	:	get current workbenches list for editing
	LastChange	:	
*/

CREATE PROCEDURE [layout].[GetProductionLines]
	@UserID	int,
	@XML	XML	OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@timeStamp			datetime,
			@timeOut			smallint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID)
	values(5, @UserID)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].GetSettingKeyValue @Key = N'SESSION_EXPIRES_IN_MINUTES', @ProcedureLogID = @procedureLogID, @Value = @timeOut OUTPUT

		set @XML = (
			select CONVERT(char(23), [global].[GetDate](), 121) [timeStamp],
				(select LocationID [location], [Name] [name], [Description] [description],
					[Tags] [tags], [Timeout] [timeOut]
				from layout.Line
				order by LocationID, [Name]
				for xml path('line'), root('lines'), type, elements XSINIL),
				(select l.LocationID [location], c.[Name] [name], c.[Description] [description],
					l.Name [line], ISNULL(c.[Timeout], l.[Timeout]) [timeOut]
				from layout.Cell c
					inner join layout.Line l on c.LineID = l.ID
				order by l.LocationID, l.[Name], c.[Name]
				for xml path('cell'), root('cells'), type, elements XSINIL),
				(select l.LocationID [location], l.[Name] [line], c.[Name] [cell], 
					w.[Name] [name], w.[Description] [description], w.ExternalReference [reference],
					pw.[Name] [previousMachine], w.EOL [eol], wt.[Name] [machineType],
					w.HourCapacity [capacity], w.Routing [routing], ISNULL(w.[Timeout], ISNULL(c.[Timeout], l.[Timeout])) [timeOut]
				from layout.Workbench w
					inner join layout.Cell  c on w.CellID = c.ID
					inner join layout.Line l on c.LineID = l.ID
					left join layout.Workbench pw on w.PreviousWorkbenchID = pw.ID
					left join layout.WorkbenchType wt on w.TypeID = wt.ID
				order by l.LocationID, l.Name, c.Name, w.Name
				for xml path('machine'), root('machines'), type, elements XSINIL)
			for xml path('root'), type)
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @xml
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [log].[LogErrorInfo]...';


GO
CREATE PROCEDURE [log].[LogErrorInfo]
	@procedureId tinyint
AS
		declare @errorNumber int = 0;
		set @errorNumber = ERROR_NUMBER();
		declare @error nvarchar(4000);
		set @error = N'[' + ERROR_PROCEDURE() + N']' + ERROR_MESSAGE()
		exec [log].LogError @procedureId = @procedureId, @errorId = 1, @message = @error, @devError = 'internal error';
RETURN 0
GO
PRINT N'Creating [users].[Logout]...';


GO
CREATE PROCEDURE [users].[Logout]
	@token nvarchar(MAX)
AS
	set nocount on;
	DECLARE @workbenchId BIGINT
	DECLARE @profileId BIGINT

	exec [users].[ForceLogoutIfTokensHaveExpired];

	begin try
		begin tran
		update act
		set act.LogoutTime = [global].[GetDate](),
			act.IsActive = 0
		from [users].AccountToken act
		inner join [users].[Account] a on act.AccountID = a.ID
		left join [layout].WorkbenchStatus wbs on act.WorkbenchID = wbs.WorkbenchID
		where act.Token = @token;

		update wbs
		set wbs.LoggedInProfileID = null
		from [users].AccountToken act
		inner join [layout].WorkbenchStatus wbs on act.WorkbenchID = wbs.WorkbenchID
		where act.Token = @token;

		commit tran
		return 0;
	end try
	begin catch
		if (@@TRANCOUNT > 0) rollback tran;
		PRINT ERROR_MESSAGE()
	end catch
RETURN -1 -- failed
GO
PRINT N'Creating [users].[Login]...';


GO
/*
 *  Checks if an operator with the given credentials exist (barcode = username, password = password)
 *  Logs in the operator on the given workbench
 *		NOTE: The difference from LoginWithOperatorBarcode is that the operator is not uniquely associated to a workbench
 *	Creates an account token for the profile
 *	Returns the account token and the profileId if successful
 *	It tries repeatedly to generate a unique token. If it fails, it returns an error.
 *
 * @param: @barcode	- operator barcode as displayed on the badge
 * @param: @password - md5 encrypted password
 * @param: @workbenchId - target workbench where to login
 */
CREATE PROCEDURE [users].[Login]
	@barcode nvarchar(50),
	@password nvarchar(50),
	@workbenchId int = null,
	@token nvarchar(MAX) OUTPUT,
	@profileId int OUTPUT
AS
	set nocount on;
	declare @errorNumber int = 0;

	set @token = null;
	set @profileId = 0;
	-- basic checks for username and password
	if (ltrim(rtrim(@barcode)) = N'') goto Error_UsernameEmpty;
	if (ltrim(rtrim(@password)) = N'') goto Error_PasswordEmpty;
	
	declare @workbenchExists bit = 0;

	if (@workbenchId is not null)
	begin
		select @workbenchExists = 1 from [layout].Workbench where ID = @workbenchId;
		if (@workbenchExists = 0) goto Error_WorkbenchDoesNotExist;
	end

	begin try
		-- find the account
		declare @userAccountId int;

		select		@userAccountId = a.ID, @profileId = a.ProfileID 
		from		[users].Account a
		inner join	[users].Profile p on a.ProfileID = p.ID
		where		ISNULL(a.[Username], '') = @barcode 
					and ISNULL(a.[Password], '') = @password 
					and a.[AccountProviderID] = 1 -- TrueHR
					and ISNULL(p.IsActive, 0) = 1

		if ((@userAccountId is null) or (@profileId is null)) 
		begin 
			set @errorNumber = -441; 
			goto Error_Other; 
		end -- throw 50441, N'Error_WrongCredentials', 1;	
	
		-- create a new account token for the user
		exec [users].[ForceLogoutIfTokensHaveExpired];

		begin tran
			declare @targetWorkbenchId int = ISNULL(@workbenchId, 0);

			update wbs
			set LoggedInProfileID = @profileId
			from [layout].WorkbenchStatus wbs  
			where wbs.WorkbenchID = @targetWorkbenchId;


			SET @token = convert(nvarchar(MAX), newid())
			exec [users].InsertOrUpdateToken @token = @token, @userAccountId = @userAccountId, @workbenchId = @targetWorkbenchId;
		commit tran
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER();
		declare @error nvarchar(4000);
		set @error = N'[' + ERROR_PROCEDURE() + N']' + ERROR_MESSAGE()

		-- declare @procedureId tinyint = [log].[GetProcedureID]('[Users].[LoginWithOperatorBarcode]');
		-- exec [log].LogError @procedureId = @procedureId, @errorId = 1, @message = @error, @devError = 'internal login error';
		goto Error;
	end catch
		
RETURN 0;
Error:
	IF (@@TRANCOUNT > 0) rollback tran;
Error_Other:
	return @errorNumber;
Error_UsernameEmpty:
	return -408;
Error_PasswordEmpty:
	return -409;
Error_WorkbenchDoesNotExist:
	return -516;
GO
PRINT N'Creating [users].[GetRights]...';


GO
/*
	Author/Date	:	Cristian Dinu, 03.08.2018
	Description	:	get current feature rights for editing
	LastChange	:	
*/

CREATE PROCEDURE [users].[GetRights]
	@UserID	int,
	@XML	XML	OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@requestorLevelID	smallint,
			@timeStamp			datetime,
			@timeOut			smallint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID)
	values(1, @UserID)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].GetSettingKeyValue @Key = N'SESSION_EXPIRES_IN_MINUTES', @ProcedureLogID = @procedureLogID, @Value = @timeOut OUTPUT

		-- get user security level
		select @requestorLevelID = LevelID
		from users.[Profile]
		where ID = @UserID

		set @XML = (
			select CONVERT(char(23), [global].[GetDate](), 121) [timeStamp], @timeout [timeOut],
				(select l.ID '@levelID', l.[Name] [level],
				case 
					when l.ID < @requestorLevelID then 0
					when hso.RequestorLevelID is NULL then 1
					when hso.RequestorLevelID < @requestorLevelID then 0
					else 1
				end 'hourly-sign-off/@enabled',
				case when hso.Operation is NULL then 0 else 1 end [hourly-sign-off],
				case 
					when l.ID < @requestorLevelID then 0
					when sso.RequestorLevelID is NULL then 1
					when sso.RequestorLevelID < @requestorLevelID then 0
					else 1
				end 'shift-sign-off/@enabled',
				case when sso.Operation is NULL then 0 else 1 end [shift-sign-off]
			from users.[Level] l
				left join users.Feature hso on l.ID = hso.TargetLevelID and hso.ID = 'hourly-sign-off'
				left join users.Feature sso on l.ID = sso.TargetLevelID and sso.ID = 'shift-sign-off'
			for xml path('right'), root('rights'), type)
			for xml path('root'), type)
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @xml
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[GetBreaks]...';


GO
/*
	Author/Date	:	Cristian Dinu, 07.08.2018
	Description	:	get current breaks list for editing
	LastChange	:	
*/

CREATE PROCEDURE [dbo].[GetBreaks]
	@UserID	int,
	@NextWeek bit = 1,
	@XML	XML	OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@timeOut			smallint,
			@nextMonday			datetime,
			@xmlMonday			datetime

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID)
	values(3, @UserID)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].GetSettingKeyValue @Key = N'SESSION_EXPIRES_IN_MINUTES', @ProcedureLogID = @procedureLogID, @Value = @timeOut OUTPUT
		set @nextMonday = [global].NextMonday([global].[GetDate]())
		set @xmlMonday = case @NextWeek when 1 then @nextMonday else DATEADD(WEEK, -1, @nextMonday) end

		set @XML = (
			select CONVERT(char(23), [global].[GetDate](), 121) [timeStamp], @timeout [timeOut],
				CONVERT(nvarchar(10), @nextMonday, 120) + N' Shift A' [startingWith], 
				(
				select l.ID '@location', 
					(select sl.ShiftType '@name', sl.ID '@shiftLogID',
						CONVERT(char(5), sl.DataStart, 114) 'from',
						case when DATEDIFF(DAY, sl.[Data], slp.DataStart) = 1 then 'Yes' end 'to/@nextDay',
						CONVERT(char(5), slp.DataStart, 114) 'to',
						(
							select  CONVERT(char(16), TimeStart, 121) '@timeStart',
								case when DATEDIFF(DAY, sl.[Data], TimeStart) = 1 then 'Yes' end 'from/@nextDay',
								CONVERT(char(5), TimeStart, 114) [from],
								case when DATEDIFF(DAY, sl.[Data], TimeEnd) = 1 then 'Yes' end 'to/@nextDay',
								CONVERT(char(5), TimeEnd, 114) [to]
							from dbo.ShiftLogBreak
							where ShiftLogID = sl.ID
							for xml path('break'), type)
					from dbo.ShiftLog sl
						inner join dbo.ShiftLog slp on sl.ID = slp.PreviousShiftLogID
					where sl.LocationID = l.ID and sl.[Data] = @xmlMonday
					order by sl.LocationID, sl.ShiftType
					for xml path('shift'), type)
				from layout.Location l
				for xml path('breaks'), type)
			for xml path('root'), type)
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @xml
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[GetPlanningDataSets]...';


GO
/*
	Author/Date	:	Cristian Dinu, 14.08.2018
	Description	:	get list of plannong data sets
	LastChange	:	
*/

CREATE PROCEDURE [target].[GetPlanningDataSets]
	@UserID	int,
	@XML	XML	OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@timeOut			smallint,
			@nextMonday			datetime,
			@lastMonday			datetime

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID)
	values(7, @UserID)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].GetSettingKeyValue @Key = N'SESSION_EXPIRES_IN_MINUTES', @ProcedureLogID = @procedureLogID, @Value = @timeOut OUTPUT
		set @nextMonday = [global].NextMonday([global].[GetDate]())
		set @lastMonday = DATEADD(WEEK, -1, @nextMonday)

		set @XML = (
			select CONVERT(char(23), [global].[GetDate](), 121) [timeStamp], @timeout [timeOut],
				CONVERT(nvarchar(10), @nextMonday, 120) + N' Shift A' [startingWith], 
				(
					select d.ID '@dailyTargetID', d.LocationID '@location', l.Tags '@tags',
						case when slso.SignedOffOperatorID is NULL then 'Yes' else 'No' end '@open',
						d.LineID 'line/@id', l.[Name] line, CONVERT(nvarchar(10), d.[Data], 120) [date], d.ShiftType [shift],
						d.TypeID [type], case d.Billboard when 1 then 'Yes' else 'No' end [billboard],
						h1.[Value] qtyHour_1, h2.[Value] qtyHour_2, h3.[Value] qtyHour_3,
						h4.[Value] qtyHour_4, h5.[Value] qtyHour_5, h6.[Value] qtyHour_6,
						h7.[Value] qtyHour_7, h8.[Value] qtyHour_8, d.[Value] qtyTotal
					from [target].vDaily d
						left join dbo.ShiftLogSignOff slso on d.LineID = slso.LineID and d.ShiftLogID = slso.ShiftLogID
						inner join layout.Line l on d.LineID = l.ID
						left join [target].Hourly h1 on d.ID = h1.DailyID and h1.[Hour] = 1
						left join [target].Hourly h2 on d.ID = h2.DailyID and h2.[Hour] = 2
						left join [target].Hourly h3 on d.ID = h3.DailyID and h3.[Hour] = 3
						left join [target].Hourly h4 on d.ID = h4.DailyID and h4.[Hour] = 4
						left join [target].Hourly h5 on d.ID = h5.DailyID and h5.[Hour] = 5
						left join [target].Hourly h6 on d.ID = h6.DailyID and h6.[Hour] = 6
						left join [target].Hourly h7 on d.ID = h7.DailyID and h7.[Hour] = 7
						left join [target].Hourly h8 on d.ID = h8.DailyID and h8.[Hour] = 8
					where d.[Data] >= @lastMonday 
					order by d.LocationID, l.[Name], d.[Data], d.TypeID, d.ShiftType
					for xml path('row'), type, ELEMENTS XSINIL)
			for xml path('root'), type)
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @XML
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[GetTargetByDay]...';


GO
/*
	Author/Date	:	Cristian Dinu, 28.08.2018
	Description	:	get targets edited in PlannigByDate methode
	LastChange	:	
*/

CREATE PROCEDURE [target].[GetTargetByDay]
	@UserID			int,
	@DailyTargetID	int,			-- if is not NULL, @targetXML will return targets for corresponding line (no matter @Tags value)
	@Tags			nvarchar(100),	-- if is not NULL, @targetXML will return targets for all line that mach tags values
									-- if both are NULL, @targetXML return NULL
	@weeksXML		XML	OUTPUT,		-- xml data set for week/day screen aria
	@targetsXML		XML	OUTPUT		-- xml for line targets screen aria
AS
	set nocount on
	set datefirst 1

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@timeOut			smallint,
			@lastMonday			datetime,
			@firstOpenShiftID	int,
			@maxNoOfLine		tinyint = 10,	
			@moreLine			nchar(3)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, CustomParams)
	values(18, @UserID,
		N'@DailyTargetID=' + ISNULL(CONVERT(nvarchar(10), @DailyTargetID), N'NULL') + N',' +
		N'@Tags=' + ISNULL(@Tags, N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		if @DailyTargetID is not NULL
			exec [global].CheckObjectID @ObjectSchema = N'target', @ObjectTable = N'Daily', @ObjectID = @DailyTargetID, @CheckIsNull = 0, @ProcedureLogID = @procedureLogID
		exec [global].GetSettingKeyValue @Key = N'SESSION_EXPIRES_IN_MINUTES', @ProcedureLogID = @procedureLogID, @Value = @timeOut OUTPUT

		-- setting constant parameters
		set @lastMonday = DATEADD(day, -7, [global].NextMonday([global].[GetDate]()))
		select @firstOpenShiftID = MIN(ID) from dbo.vShiftLog where dataStart > [global].[GetDate]()


		declare @days table(ShiftLogID int, Data datetime)
		declare @lines table(ID smallint IDENTITY(1,1), LineID int, Name nvarchar(50), Tags nvarchar(max), Capacity smallint, FirstOpenShiftID int)
		declare @targets table(ID int, LineID int, ShiftLogID int, [Day] tinyint, ShiftType char(1), Value smallint)

		insert into @days(ShiftLogID, [Data])
		select ID, [Data]
		from dbo.ShiftLog
		where DATEDIFF(DAY, @lastMonday, [Data]) between 0 and 13
		order by [Data]

		if @DailyTargetID is not NULL
			insert into @lines(LineID, [Name], Tags, Capacity)
			select d.LineID, vl.[name], vl.tags, vl.capacity
			from [target].Daily d
				inner join [layout].vActiveLines vl on d.LineID = vl.id
			where d.ID = @DailyTargetID
		else if @Tags is not NULL
		begin

/*
			-- prepare @Tags for CONTAIMNES
			-- remove all trailing spaces and replace commas with blanks
			set @Tags = REPLACE(RTRIM(LTRIM(@tags)), N',', N' ')
			-- a single blank should exist between words 
			while CHARINDEX(N'  ', @tags, 1) <> 0
			begin
				set @tags = REPLACE(@tags, N'  ', N' ')
			end
			---- add AND operator (for CONTAINS)
			--set @tags = REPLACE(@tags, N' ', N' AND ')

			set @tags = N'%' + REPLACE(@tags, N' ', N'%') + N'%'

			insert into @lines(LineID, [Name], Tags)
			select ID, [Name], Tags
			from [layout].Line
			--where CONTAINS(Tags, @Tags)
			where Tags like @Tags
--				or [Name] like @Tags
			order by [Name]
*/

			insert into @lines(LineID, [Name], Tags)
			select distinct l.ID, l.[Name], l.Tags
			from [layout].Line l
				inner join [layout].LineTag lt on l.ID = lt.LineID
			where lt.Tag = @Tags
			order by [Name]

			-- limit max no of line in XML
			if @@ROWCOUNT > @maxNoOfLine set @moreLine = 'yes'
			if @moreLine = 'yes'
				delete @lines where ID > @maxNoOfLine
		end
		else goto NoLines

		-- add Capacity and FirstOpenShiftID info
		update _l
		set Capacity = ISNULL(lc.Capacity, 0),
			FirstOpenShiftID = ISNULL(sl.FirstOpenShiftID, @firstOpenShiftID)
		from @lines _l
			left join (
				select c.LineID, ROUND(SUM(w.HourCapacity) * 8 * 11 / 12, 0) Capacity
				from layout.Cell c
					inner join layout.Workbench w on c.ID = w.CellID
				where w.EOL = 1
				group by c.LineID
			) lc on _l.LineID = lc.LineID
			left join (
				select LineID, MIN(ShiftLogID) FirstOpenShiftID
				from dbo.ShiftLogSignOff
				where SignedOffOperatorID is NULL
				group by LineID
			) sl on _l.LineID = sl.LineID

		insert into @targets(ID, LineID, ShiftLogID, [Day], [ShiftType], [Value])
		select d.ID, _l.LineID, sl.ID, DATEDIFF(DAY, @lastMonday, sl.[Data]) + 1, sl.ShiftType, d.[Value]
		from @lines _l
			cross join dbo.ShiftLog sl
			left join [target].Daily d on _l.LineID = d.LineID and sl.ID = d.ShiftLogID and d.TypeID = 'DY'
		where sl.ID in (select ShiftLogID from @days)
		order by _l.[Name], sl.[Data], sl.ShiftType

		set @targetsXML = (
			select a.*
			from (
				select 1 as Tag,
					NULL as Parent,
					@moreLine as [targets!1!moreLinesAvailable],
					CONVERT(char(23), [global].[GetDate](), 121) [targets!1!timeStamp],
					@timeout [targets!1!timeOut], 
					NULL as [forLine!2!name],
					NULL as [forLine!2!tags],
					NULL as [forLine!2!shiftCapacity],
					NULL as [forLine!2!firstOpenShiftLogId],
					NULL as [forLine!2!id],
					NULL as [target!3!shiftLogId],
					NULL as [target!3!day],
					NULL as [target!3!name],
					NULL as [target!3!id],
					NULL AS [target!3]
				union all
				select distinct
					2 as Tag,
					1 as Parent,
					@moreLine as [target!1!moreLinesAvailable],
					CONVERT(char(23), [global].[GetDate](), 121) [timeStamp!1],
					@timeout [timeOut!1], 
					[Name],
					ISNULL(Tags, N''),
					Capacity,
					FirstOpenShiftID,
					LineID,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL
				from @lines _l
				union all
				select 3 as Tag,
					2 as Parent,
					@moreLine as [target!1!moreLinesAvailable],
					CONVERT(char(23), [global].[GetDate](), 121) [timeStamp!1],
					@timeout [timeOut!1], 
					_l.[Name],
					_l.Tags,
					_l.Capacity,
					_l.FirstOpenShiftID,
					_t.LineID,
					_t.ShiftLogID,
					_t.[Day],
					_t.ShiftType,
					_t.ID,
					_t.Value
				from @lines _l
					inner join @targets _t on _l.LineID = _t.LineID) a
			order by a.[forLine!2!name], a.[target!3!day], a.[target!3!name]
			for xml explicit, root('root'))
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @targetsXML
		where ID = @procedureLogID

NoLines:
		set @weeksXML = (
			select
				(select DATENAME(WEEK, Data) '@id', CONVERT(char(10), MIN(Data), 120) 'start', CONVERT(char(10), MAX(Data), 120) 'end'
				from @days
				group by DATENAME(WEEK, Data)
				order by '@id'
				for xml path('week'), root('weeks'), type)
			for xml path('root'), type)
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[GetTargetByPartNumber]...';


GO
/*
	Author/Date	:	Cristian Dinu, 08.09.2018
	Description	:	get targets edited in PlannigByPartNumber methode
	LastChange	:	
*/
CREATE PROCEDURE [target].[GetTargetByPartNumber]
	@UserID			int,
	@DailyTargetID	int,			-- if is not NULL, @targetXML will return targets for corresponding line (no matter @Tags value)
	@LineID			int,			-- if is not NULL, @targetXML will return cells and associated machines
	@Date			datetime,		-- if @LineID and @Date are not NULL, @targetXML will return targets as case of @DailyTargetID not NULL
	@targetsXML		XML	OUTPUT		-- xml for line + date targets
AS
	set nocount on

	declare @errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint,
			@timeOut			smallint,
			@capacity			smallint

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, CustomParams)
	values(20, @UserID,
		N'@DailyTargetID=' + ISNULL(CONVERT(nvarchar(10), @DailyTargetID), N'NULL') + N',' +
		N'@LineID=' + ISNULL(CONVERT(nvarchar(10), @LineID), N'NULL') + N',' +
		N'@Date=' + ISNULL(CONVERT(nvarchar(10), @Date, 120), N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		if @DailyTargetID is not NULL
			exec [global].CheckObjectID @ObjectSchema = N'target', @ObjectTable = N'Daily', @ObjectID = @DailyTargetID, @CheckIsNull = 0, @ProcedureLogID = @procedureLogID
		if @LineID is not NULL
			exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @LineID, @CheckIsNull = 0, @ProcedureLogID = @procedureLogID
		exec [global].GetSettingKeyValue @Key = N'SESSION_EXPIRES_IN_MINUTES', @ProcedureLogID = @procedureLogID, @Value = @timeOut OUTPUT

		declare @rows table([Priority] smallint, PartNumber nvarchar(50), InitialQuantity smallint, Routing smallint, Totals smallint, PartNumberID int)
		declare @targets table(DailyID int, ShiftType char(1), Closed bit)

		if @DailyTargetID is not NULL
			select @lineID = LineID, @Date = [Data]
			from [target].vDaily
			where ID = @DailyTargetID

		if @LineID is not NULL and @Date is not NULL
		begin
			insert into @targets(DailyID, ShiftType, Closed)
			select d.ID, d.ShiftType,
				case when sso.SignedOffOperatorID is not NULL then 1 else 0 end
			from [target].vDaily d
				left join dbo.ShiftLogSignOff sso on d.ShiftLogID = sso.ShiftLogID and d.LineID = sso.LineID
			where d.TypeID = 'PN'
				and d.LineID = @LineID
				and d.[Data] = @Date

			insert into @rows([Priority], PartNumber, InitialQuantity, Routing, Totals, PartNumberID)
			select tpn.[Priority], pn.PartNumber, SUM(tpn.InitialQty), pn.Routing, SUM(tpn.[Value]), pn.ID
			from [target].PartNumber tpn
				inner join layout.PartNumber pn on tpn.PartNumberID = pn.ID
			where tpn.DailyID in (select DailyID from @targets)
			group by tpn.[Priority], pn.PartNumber, pn.Routing, pn.ID
			order by tpn.[Priority]
		end

		-- calculate line capacity
		select @capacity = capacity
		from layout.vActiveLines
		where ID = @LineiD

		-- generate XML
		set @targetsXML = (
			select CONVERT(char(23), [global].[GetDate](), 121) [timeStamp], @timeout [timeOut],
				l.ID 'line/@id', @capacity 'line/@shiftCapacity', l.[Name] 'line', CONVERT(nvarchar(10), @Date , 120) 'date',
				(select top 1 ShiftType from @targets where Closed = 1 order by ShiftType desc) 'firstClosedShift',
				(
					select c.Name 'name',
					(
						select Name 'machine/@name', Routing 'machine'
						from layout.Workbench
						where CellID = c.ID
						for xml path(''), root('machines'), type
					)
					from layout.Cell c
					where c.LineID = l.ID
					for xml path('cell'), root('cells'), type
				),
				(
					select _r.[Priority] '@priority', _r.partNumber, _r.initialQuantity, _r.routing, _r.totals,
					(
						select _d.ShiftType 'shift/@name',
 							tpn.[Value] 'shift'
						from [target].PartNumber tpn
							inner join @targets _d on tpn.DailyID = _d.DailyID
						where tpn.PartNumberID = _r.partNumberID
						for xml path(''), root('shifts'), type
					)
					from @rows _r
					order by '@priority'
					for xml path('row'), root('rows'), type
				),
				(
					select _d.ShiftType '@name',
						_d.DailyID '@dailyID',
					(
						select [Hour] 'hour/@interval',
							[Value] 'hour'
						from [target].Hourly
						where DailyID = _d.DailyID
						order by 'hour/@interval'
						for xml path(''), type
					)
					from @targets _d
					order by '@name'
					for xml path('shift'), root('dataset'), type
				)
			from layout.Line l
			where ID = @LineID
			for xml path('root'), type, ELEMENTS XSINIL)
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @targetsXML
		where ID = @procedureLogID

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[SaveTargetByDay]...';


GO
/*
	Author/Date	:	Cristian Dinu, 29.08.2018
	Description	:	process targets by day data set
	LastChange	:
*/

CREATE PROCEDURE [target].[SaveTargetByDay]
	@UserID			int,
	@TargetsXML		XML,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@timeStamp			datetime,
			@procedureLogID		bigint
	declare @txml table(
				DailyID		int,
				LineID		int,
				ShiftLogID	int,
				sValue		varchar(10),
				[Value]		smallint)
	declare @hourly table(
				DailyID		int,
				[Hour]		tinyint,
				[Value]		smallint,
				TimeStart	datetime,
				TimeEnd		datetime)
	declare @hours table([Hour] tinyint)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, XMLParam)
	values(19, @UserID, @TargetsXML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get info from XML
		insert into @txml(DailyID, LineID, ShiftLogID, sValue)
		select
			T.[targets].value('@id', 'int') as [DailyID],
			T.[targets].value('../@id', 'int') as [LineID],
			T.[targets].value('@shiftLogId', 'int') as [ShiftLogID],
			T.[targets].value('.', 'varchar(10)') as [Value]
		from @TargetsXML.nodes('//target') as T([targets])

		select @timeStamp = CONVERT(datetime, T.[Break].value('.', 'char(23)'), 121)
		from @TargetsXML.nodes('/root/targets/@timeStamp') as T([Break])
		if @@ROWCOUNT = 0 goto WrongXML

		-- checking zone
		-- if exist recent updates, after XML timestamp
		select top 1 @errorMessage = N'During current edit session another user started targets changes session'
		from @txml _t
			inner join [target].Daily d on _t.LineID = d.LineID and _t.ShiftLogID = d.ShiftLogID
		where d.TypeID = 'DY'
			and d.UpdateDate > @timeStamp
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if there are empty fields
		select top 1 @errorMessage = N'There are records with missing LineID values'
		from @txml
		where LineID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing ShiftLogID values'
		from @txml
		where ShiftLogID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with non-numeric Target values'
		from @txml
		where LEN(sValue) > 0
			and ISNUMERIC(sValue) = 0

		select top 1 @errorMessage = N'There are records with too big Target values'
		from @txml
		where CONVERT(int, sValue) > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit
		else
			update @txml
			set [Value] = CONVERT(smallint, sValue)
			where LEN(sValue) > 0

		-- check if DailyID is correct
		select top 1 @errorMessage = N'There are records with incorrect DailyID values (e.g. ' + CONVERT(nvarchar(10), DailyID) + N')'
		from @txml
		where DailyID is not NULL
			and DailyID not in (select ID from [target].Daily)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if DailyID record is TypeID = 'DY'
		select top 1 @errorMessage = N'There are edited records with incorrect TargetTypeID values (e.g. ' + CONVERT(nvarchar(10), DailyID) + N')'
		from @txml
		where DailyID is not NULL
			and DailyID not in (select ID from [target].Daily where TypeID = 'DY')
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if ShiftLogID is correct
		select top 1 @errorMessage = N'There are records with incorrect ShiftLogID values (e.g. ' + CONVERT(nvarchar(10), ShiftLogID) + N')'
		from @txml
		where ShiftLogID not in (select ID from dbo.ShiftLog)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if LineID is correct
		select top 1 @errorMessage = N'There are records with incorrect ShiftLogID values (e.g. ' + CONVERT(nvarchar(10), LineID) + N')'
		from @txml
		where LineID not in (select ID from layout.Line)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Value is correct
		select top 1 @errorMessage = N'There are records with negative Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml
		where [Value] < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if existing Daily records are same LineID and ShiftLogID
		select top 1 @errorMessage = N'There are edited records with LineID or ShiftLogID corrupted (e.g. ' + CONVERT(nvarchar(10), _t.DailyID) + N')'
		from @txml _t
			inner join [target].Daily d on _t.DailyID = d.ID
		where _t.LineID <> d.LineID
			or _t.ShiftLogID <> d.ShiftLogID
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- total shift target > line capacity
		select top 1 @errorMessage = N'Total target on ' + CONVERT(nchar(10), sl.[Data], 120) + N' - shift '
			+ sl.ShiftType + N' (' + FORMAT(_t.[Value], '#,##0') + N') is greater then '
			+ lc.[Name] + N' line capacity (' + FORMAT(lc.LineCapacity, '#,##0') + N')'
		from @txml _t
			inner join (
				select l.ID, l.[Name], ROUND(SUM(w.HourCapacity) * 8 * 11 / 12, 0) LineCapacity
				from layout.Line l
					inner join layout.Cell c on l.ID = c.LineID
					inner join layout.Workbench w on c.ID = w.CellID
				where w.EOL = 1
				group by l.ID, l.[Name]
			) lc on _t.LineID = lc.ID
			inner join dbo.ShiftLog sl on _t.ShiftLogID = sl.ID
		where _t.[Value] is not NULL
			and _t.[Value] > lc.LineCapacity
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- data updates zone
		begin tran
			-- insert new targets
			insert into [target].Daily(TypeID, LineID, ShiftLogID, [Value], UpdateUserID, UpdateDate)
			select 'DY', LineID, ShiftLogID, [Value], @UserID, [global].[GetDate]()
			from @txml
			where DailyID is NULL
				and [Value] is not NULL

			-- update daily targets
			update d
			set [Value] = _t.[Value],
				UpdateUserID = @UserID,
				UpdateDate = [global].[GetDate]()
			from [target].Daily d
				inner join @txml _t on d.ID = _t.DailyID
			where _t.[Value] is not NULL
				and d.[Value] <> _t.[Value]

			-- delete daily targets
			delete h
			from [target].Hourly h
				inner join @txml _t on h.DailyID = _t.DailyID
			where _t.[Value] is NULL

			delete d
			from [target].Daily d
				inner join @txml _t on d.ID = _t.DailyID
			where _t.[Value] is NULL

			-- save DailyID for new records
			update _t
			set DailyID = d.ID
			from @txml _t
				inner join [target].Daily d on _t.LineID = d.LineID and _t.ShiftLogID = d.ShiftLogID
			where d.TypeID = 'DY'
				and _t.DailyID is NULL


			-- edit hourly values
			-- create hourly values
			insert into @hours([Hour]) values (1), (2), (3), (4), (5), (6), (7), (8)

			-- set equaly value for each hour without breaks
			insert into @hourly(DailyID, [Hour], [Value], TimeStart, TimeEnd)
			select _t.DailyID, _h.[Hour],
				case _h.[Hour] % 2
					when 0 then CEILING(CONVERT(decimal(10,2), _t.[Value]) / 440 * 480 / 8)
					else FLOOR(CONVERT(decimal(10,2), _t.[Value]) / 440 * 480 / 8)
				end,
				DATEADD(HOUR, _h.[Hour] - 1, sl.DataStart), DATEADD(HOUR, _h.[Hour], sl.DataStart)
 			from @txml _t
				cross join @hours _h
				inner join dbo.ShiftLog sl on _t.ShiftLogID = sl.ID
			where _t.[Value] is not NULL

			--  adjust value for hour intervals affected by breaks
			update _h
			set [Value] = case
							when slb0.ShiftLogID is not NULL then ROUND(CONVERT(decimal(10,2), _h.[Value]) * DATEDIFF(MINUTE, _h.TimeStart, slb0.TimeStart) / 60, 0)
							else 0
						end +
						case
							when slb1.ShiftLogID is not NULL then ROUND(CONVERT(decimal(10,2), _h.[Value]) * DATEDIFF(MINUTE, slb1.TimeEnd, _h.TimeEnd) / 60, 0)
							else 0
						end
			from @hourly _h
				left join dbo.ShiftLogBreak slb0 on slb0.TimeStart between _h.TimeStart and _h.TimeEnd
				left join dbo.ShiftLogBreak slb1 on slb1.TimeEnd between _h.TimeStart and _h.TimeEnd
			where slb0.ShiftLogID is not NULL
				or slb1.ShiftLogID is not NULL

			-- adjust last hour interval with differencws from rounding
			update _h8
			set [Value] += d.[Value] - _d.[Value]
			from @hourly _h8
				inner join [target].Daily d on _h8.DailyID = d.ID
				inner join (
					select DailyID, SUM([Value]) [Value]
					from @hourly
					group by DailyID
				) _d on _h8.DailyID = _d.DailyID
			where _h8.[Hour] = 8

			-- update Hourly table
			insert into [target].Hourly(DailyID, [Hour], [Value], CumulativeValue, UpdateUserID, UpdateDate)
			select _h.DailyID, _h.[Hour], _h.[Value], _h.[Value], @UserID, [global].[GetDate]()
			from @hourly _h
				left join [target].Hourly h on _h.DailyID = h.DailyID and _h.[Hour] = h.[Hour]
			where h.ID is NULL

			update h
			set [Value] = _h.[Value],
				CumulativeValue = _h.[Value],
				UpdateUserID = @UserID, UpdateDate = [global].[GetDate]()
			from @hourly _h
				inner join [target].Hourly h on _h.DailyID = h.DailyID and _h.[Hour] = h.[Hour]
			where h.[Value] <> -h.[Value]

			-- generate cumulative values
			update h
			set CumulativeValue = (select SUM([Value])
				from [target].[Hourly]
				where DailyID = h.DailyID
					and [Hour] <= h.[Hour])
			from [target].[Hourly] h
			where h.DailyID in (select DailyID from @txml)

			-- set target on billboard if new records are the first on LineID + Date combination
			declare @dailyIDs idTable

			insert into @dailyIDs(ID)
			select MIN(d.ID)
			from [target].Daily d
				left join [target].Daily dd on d.LineID = dd.LineID and d.ShiftLogID = dd.ShiftLogID and d.ID <> dd.ID
			where d.Billboard = 0
				and dd.ID is NULL
			group by d.LineID, d.ShiftLogID

			if @@ROWCOUNT > 0
				exec [target].[SetBillboardOnByIDList] @UserID = @UserID, @DailyIDs = @dailyIDs

		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[SaveTargetByPartNumber]...';


GO
/*
	Author/Date	:	Cristian Dinu, 10.09.2018
	Description	:	process targets by partnumber data set
	LastChange	:
*/

CREATE PROCEDURE [target].[SaveTargetByPartNumber]
	@UserID			int,
	@TargetsXML		XML,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@timeStamp			datetime,
			@procedureLogID		bigint,
			@sDate				varchar(50),
			@date				datetime,
			@lineID				int,
			@capacity			smallint,
			@eolMachines		smallint,
			@editMode			tinyint	-- 0=new, 1=edit(same line+data), 2=edit(different line+data) 
	declare @txml_pn table(
					[Priority]	smallint,
					PartNumber	nvarchar(50),
					InitialQty	int,
					Totals		int,
					ShiftType	char(1),
					[Value]		int)
	declare @txml_hour table(
					TargetDailyID	int,
					[Hour]			tinyint,
					ShiftType		char(1),
					[Value]			int)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, XMLParam)
	values(21, @UserID, @TargetsXML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get info from XML
		select @lineID = T.[targets].value('line[1]/@id', 'int'),
				@sDate = T.[targets].value('date[1]', 'char(10)'),
				@timeStamp = CONVERT(datetime, T.[targets].value('timeStamp[1]', 'char(23)'), 121)
		from @TargetsXML.nodes('//root') as T([targets])
		if @@ROWCOUNT = 0 goto WrongXML

		-- check if LineID is valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @lineID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		-- check if Data is correct
		if ISDATE(@sDate) = 0 goto IncorrectDate
		else set @date = CONVERT(datetime, @sDate, 120)

		-- get Line info
		select @capacity = capacity,
				@eolMachines = eolMachines
		from layout.vActivelines
		where id = @lineID

		-- get rows from XML
		insert into @txml_pn([Priority], PartNumber, InitialQty, Totals, ShiftType, [Value])
		select
			T.[targets].value('../../@priority', 'smallint') as [Priority],
			T.[targets].value('../../partNumber[1]', 'nvarchar(50)') as [PartNumber],
			T.[targets].value('../../initialQuantity[1]', 'int') as [InitialQty],
			T.[targets].value('../../totals[1]', 'int') as [Totals],
			T.[targets].value('@name', 'char(1)') as [ShiftType],
			ISNULL(T.[targets].value('.', 'int'), 0) as [Value]
		from @TargetsXML.nodes('//shifts/shift') as T([targets])
		order by [Priority]
		if @@ROWCOUNT = 0 goto WrongXML

		insert into @txml_hour([Hour], ShiftType, TargetDailyID, [Value])
		select
			T.[targets].value('@interval', 'tinyint') as [Hour],
			T.[targets].value('../@name', 'char(1)') as [ShiftType],
			T.[targets].value('../@dailyID', 'int') as [TargetDailyID],
			ISNULL(T.[targets].value('.', 'int'), 0) as [Value]
		from @TargetsXML.nodes('//dataset/shift/hour') as T([targets])
		if @@ROWCOUNT = 0 goto WrongXML

		-- add TargetDaily/HourlyID information
		-- id is not saved in XML because in web form <hour> elements can be deleted and recreated

		-- identify what is current and new planning status
		-- 0 = no current line+date combination, new datasets should be generated
		-- 1 = line+date combination already exists, line and date remain unghanged
		-- 2 = line+date combination already exists, line and/or date are unghanged
		--		new line+date combination should not exists, otherwise return error
		select @editMode = case when d.LineID = @lineID and d.[Data] = @date then 1 else 2 end
		from (select distinct TargetDailyID from @txml_hour) _d
			inner join [target].vDaily d on _d.TargetDailyID = d.ID
		if @@ROWCOUNT = 0 set @editMode = 0

		-- checking zone
		-- if exist recent updates, after XML timestamp
		select top 1 @errorMessage = N'During current edit session another user started targets changes session'
		from [target].PartNumber pn
			inner join [target].vDaily d on pn.DailyID = d.ID
		where d.LineID = @LineID
			and d.[Data] = @Date
			and pn.UpdateDate > @timeStamp
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'During current edit session another user started targets changes session'
		from [target].vHourly
		where LineID = @LineID
			and ShiftData = @Date
			and UpdateDate > @timeStamp
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if there are empty fields
		select top 1 @errorMessage = N'There are records with missing Priority values'
		from @txml_pn
		where [Priority] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing PartNumber values'
		from @txml_pn
		where PartNumber is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing InitialQuantity values'
		from @txml_pn
		where InitialQty is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Totals values'
		from @txml_pn
		where Totals is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing PartNumber.ShiftType values'
		from @txml_pn
		where ShiftType is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing PartNumber target values'
		from @txml_pn
		where [Value] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Hourly.Interval values'
		from @txml_hour
		where [Hour] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Hourly.ShiftType values'
		from @txml_hour
		where ShiftType is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Hourly target values'
		from @txml_hour
		where [Value] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if PartNumber.ShiftType record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect PartNumber.ShiftType values (e.g. ' + ShiftType + N')'
		from @txml_pn
		where ShiftType not in ('A', 'B', 'C')
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly.Hour record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect Hourly.Interval values (e.g. shift ' + ShiftType + N', interval ' + CONVERT(nvarchar(10), [Hour]) + N')'
		from @txml_hour
		where [Hour] not between 1 and 8
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Priority record is doubled
		select top 1 @errorMessage = N'There are edited records with doubled PartNumber.Priority values (e.g. shift ' + ShiftType + N', Priority ' + CONVERT(nvarchar(10), [Priority]) + N')'
		from @txml_pn
		group by ShiftType, [Priority]
		having COUNT(*) > 1
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly.Hour record is doubled
		select top 1 @errorMessage = N'There are edited records with doubled Hourly.Interval values (e.g. shift ' + ShiftType + N', interval ' + CONVERT(nvarchar(10), [Hour]) + N')'
		from @txml_hour
		group by ShiftType, [Hour]
		having COUNT(*) > 1
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly.ShiftType record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect Hour.ShiftType values (e.g. ' + ShiftType + N')'
		from @txml_hour
		where ShiftType not in ('A', 'B', 'C')
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if PartNumber record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect PartNumber values (e.g. ' + PartNumber + N')'
		from @txml_pn
		where PartNumber not in (select PartNumber from layout.PartNumber)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if quantity values are correct
		select top 1 @errorMessage = N'There are records with negative InitialQuantity values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where InitialQty < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with negative Totals values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where Totals < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with negative PartNumber/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where [Value] < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with negative Hour/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_hour
		where [Value] < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if quantity values are too big
		select top 1 @errorMessage = N'There are records with too big InitialQuantity values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where InitialQty > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with too big Totals values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where Totals > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with too big PartNumber/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where [Value] > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with too big Hour/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_hour
		where [Value] > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if there are missing/dubled Hourly values (should be 8 / shift)
		select top 1 @errorMessage = N'There are shifts with incorrect number of hourly target values per shift (e.g. ' + ShiftType + N' with ' + CONVERT(nvarchar(10), COUNT([Value])) +  N')'
		from @txml_hour
		group by ShiftType
		having COUNT([Value]) <> 8
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Total is equal with InitialQuantity
		select top 1 @errorMessage = N'There are PartNumbers where Totals value is different then InitialQuantity value (e.g. ' + PartNumber + N')'
		from @txml_pn
		where Totals <> InitialQty
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if target values sum is equal with Totals for each PartNumber
		select top 1 @errorMessage = N'There are PartNumbers where Totals value is different then shift target values sum (e.g. ' + PartNumber + N')'
		from @txml_pn
		group by PartNumber, Totals
		having Totals <> SUM([Value])
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly target values sum is equal with PartNumber target values sum
		select top 1 @errorMessage = N'Total value for PartNumber split (' + CONVERT(nvarchar(10), _pn.Totals)
			+ N') is different then total values for Hourly split (' + CONVERT(nvarchar(10), _hour.Totals) + N') '
		from (
				select SUM([Value]) Totals
				from @txml_pn) _pn,
			(
				select SUM([Value]) Totals
				from @txml_hour) _hour
		where _pn.Totals <> _hour.Totals
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if PartNumber target values sum is equal with Hourly target values sum for each shift type
		select top 1 @errorMessage = N'There are shifts where PartNumber target values sum is different than Hourly target values sum (e.g. '
			+ st.ShiftType + N', Total PartNumber = ' + CONVERT(nvarchar(10), ISNULL(_pn.Totals, 0))
			+ N', Total Hourly = ' + CONVERT(nvarchar(10), ISNULL(_hour.Totals, 0)) + N')'
		from (
			select ShiftType
			from dbo.ShiftLog
			where [Data] = @Date
		) st
			left join (
				select ShiftType, SUM([Value]) Totals
				from @txml_pn
				group by ShiftType
			) _pn on st.ShiftType = _pn.ShiftType
			left join (
				select ShiftType, SUM([Value]) Totals
				from @txml_hour
				group by ShiftType
			) _hour on st.ShiftType = _hour.ShiftType
		where ISNULL(_pn.Totals, 0) <> ISNULL(_hour.Totals, 0)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if shifts are open
		select top 1 @errorMessage = N'Target values for shift ' + _h.ShiftType + N' cannot be saved because is closed'
		from @txml_hour _h
			inner join dbo.ShiftLog sl on _h.ShiftType = sl.ShiftType
			left join dbo.ShiftLogSignOff slso on sl.ID = slso.ShiftLogID
		where sl.[Data] = @date
			and slso.LineID = @lineID
			and slso.SignedOffOperatorID is not NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- in case of channging plannig dataset attributes (line or data)  there are some special checks
		if @editMode = 2
		begin
			-- if plannig data is changed, check if old shifts are open
			select top 1 @errorMessage = N'Planning dataset Date cannot be changed because corresponding shifts are already closed (e.g. shift ' + _h.ShiftType + N')'
			from @txml_hour _h
				inner join [target].Daily d on _h.TargetDailyID = d.ID
				left join dbo.ShiftLogSignOff slso on d.LineID = slso.LineID and d.ShiftLogID = slso.ShiftLogID
			where slso.SignedOffOperatorID is not NULL
			if @@ROWCOUNT <> 0 goto ErrorExit

			-- check if new Line + Data combination alread exists
			select top 1 @errorMessage = N'Planning dataset Line and/or Date cannot be changed with present values because there is already another planning dataset with same attributes'
			from @txml_hour _h
				inner join dbo.ShiftLog sl on _h.ShiftType = sl.ShiftType
				inner join [target].Daily d on sl.ID =  d.ShiftLogID
			where sl.[Data] = @date
				and d.TypeID = 'PN'
				and d.LineID = @lineID
				and _h.TargetDailyID <> d.ID
			if @@ROWCOUNT <> 0 goto ErrorExit
		end

		-- check if target match line capacity
		select top 1 @errorMessage = N'Total target values for shift ' + ShiftType
			+ N' (' + CONVERT(varchar(10), SUM([Value])) + N') exceed the line capacity (' + CONVERT(varchar(10), @capacity) + ')'
		from @txml_hour
		group by ShiftType
		having SUM([Value]) > @capacity

		-- check if target match PartNumber routing
		select top 1 @errorMessage = N'Total production time for shift '
			+ ShiftType + N', based on partnumber target values and routings (' + CONVERT(varchar(10), SUM(_pn.[Value] * pn.Routing)) 
			+ N' min) exceed shift time frame and line layout (440 minutes x ' + CONVERT(varchar(10), @eolMachines) + ' EOL Machines)'
		from @txml_pn _pn
			inner join layout.PartNumber pn on _pn.PartNumber = pn.PartNumber
		group by ShiftType
		having SUM(_pn.[Value] * pn.Routing) > 440 * @eolMachines 

		-- data updates zone
		begin tran
			-- new planning datasets
			if @editMode = 0
			begin
				insert into [target].Daily(TypeID, LineID, ShiftLogID, [Value], UpdateUserID, UpdateDate)
				select 'PN', @LineID, sl.ID, SUM([Value]), @UserID, [global].[GetDate]()
				from @txml_hour _h
					inner join dbo.ShiftLog sl on _h.ShiftType = sl.ShiftType and sl.[Data] = @Date
				group by sl.ID

				-- part number target values
				insert into [target].PartNumber(DailyID, PartNumberID, [Priority], InitialQty, [Value], UpdateUserID, UpdateDate)
				select d.ID, pn.ID, _pn.[Priority],
					case when _pn.ShiftType = 'A' then _pn.InitialQty else 0 end,
					_pn.[Value], @UserID, [global].[GetDate]()
				from @txml_pn _pn
					inner join [target].vDaily d on _pn.ShiftType = d.ShiftType
					inner join layout.PartNumber pn on _pn.PartNumber = pn.PartNumber
				where  d.TypeID = 'PN'
					and d.LineID = @LineID
					and d.[Data] = @date

				-- hourly target values
				insert into [target].Hourly(DailyID, [Hour], [Value], CumulativeValue, UpdateUserID, UpdateDate)
				select TargetDailyID, [Hour], [Value], [Value], @UserID, [global].[GetDate]()
				from @txml_hour

				-- set target on billboard if new records are the first on LineID + Date combination
				declare @dailyIDs idTable

				insert into @dailyIDs(ID)
				select MIN(d.ID)
				from [target].Daily d
					left join [target].Daily dd on d.LineID = dd.LineID and d.ShiftLogID = dd.ShiftLogID and d.ID <> dd.ID
				where d.Billboard = 0
					and dd.ID is NULL
				group by d.LineID, d.ShiftLogID

				if @@ROWCOUNT > 0
					exec [target].[SetBillboardOnByIDList] @UserID = @UserID, @DailyIDs = @dailyIDs
			end

			-- existing planning datasets
			else
			begin
				-- part numbers target values
				-- existing records
				update tpn
				set [InitialQty] = case when _pn.ShiftType = 'A' then _pn.InitialQty else 0 end,
					[PartNumberID] = lpn.ID,
					[Value] = _pn.[Value],
					UpdateUseriD = @UserID,
					UpdateDate = [global].[GetDate]()
				from @txml_pn _pn
					inner join [target].vDaily d on _pn.ShiftType = d.ShiftType
					inner join [target].PartNumber tpn on d.ID = tpn.DailyID and _pn.[Priority] = tpn.[Priority]
					inner join layout.PartNumber lpn on _pn.PartNumber = lpn.PartNumber
				where  d.TypeID in (select distinct TargetDailyID from @txml_hour)
					and (tpn.PartNumberID <> lpn.ID or tpn.[Value] <> _pn.[Value])

				-- new records
				insert into [target].PartNumber(DailyID, PartNumberID, [Priority], InitialQty, [Value], UpdateUserID, UpdateDate)
				select d.ID, lpn.ID, _pn.[Priority],
					case when _pn.ShiftType = 'A' then _pn.InitialQty else 0 end,
					_pn.[Value], @UserID, [global].[GetDate]()
				from @txml_pn _pn
					inner join [target].vDaily d on _pn.ShiftType = d.ShiftType
					left join [target].PartNumber tpn on d.ID = tpn.DailyID and _pn.[Priority] = tpn.[Priority]
					inner join layout.PartNumber lpn on _pn.PartNumber = lpn.PartNumber
				where d.TypeID in (select distinct TargetDailyID from @txml_hour)
					and tpn.ID is NULL

				-- delete missing records
				delete tpn
				from [target].PartNumber tpn
					inner join [target].Daily d on tpn.DailyID = d.ID
					left join @txml_pn _pn on tpn.DailyID = d.ID and tpn.[Priority] = _pn.[Priority]
				where  d.TypeID in (select distinct TargetDailyID from @txml_hour)
					and _pn.[Priority] is NULL

				-- hourly target values
				update h
				set [Value] = _h.[Value],
					CumulativeValue = _h.[Value],
					UpdateUseriD = @UserID,
					UpdateDate = [global].[GetDate]()
				from @txml_hour _h
					inner join [target].vDaily d on _h.ShiftType = d.ShiftType
					inner join [target].Hourly h on d.ID = h.DailyID and _h.[Hour] = h.[Hour]
				where d.TypeID in (select distinct TargetDailyID from @txml_hour)
					and h.[Value] <> _h.[Value]
			end

			if @editMode = 2
				update d
				set LineID = @lineID,
					ShiftLogID = sln.ID,
					UpdateUseriD = @UserID,
					UpdateDate = [global].[GetDate]()
				from [target].Daily d
					inner join dbo.ShiftLog slo on d.ShiftLogID = slo.ID
					inner join dbo.ShiftLog sln on slo.ShiftType = sln.ShiftType and sln.[Data] = @date
				where d.ID in (select distinct TargetDailyID from @txml_hour)

		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
	goto ErrorExit
IncorrectDate:
	set @errorMessage = N'Wrong Date value (' + @Date + N')'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'fdcef213-7beb-4f63-9529-746e034916ba')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('fdcef213-7beb-4f63-9529-746e034916ba')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b803893f-8d4f-4392-b255-94f5ad210f1e')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b803893f-8d4f-4392-b255-94f5ad210f1e')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '2f06326a-6a06-4b44-bd8d-84547265c764')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('2f06326a-6a06-4b44-bd8d-84547265c764')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'f8549984-7448-4c1a-9f34-bcea9bde9f52')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('f8549984-7448-4c1a-9f34-bcea9bde9f52')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'f8e69081-3f87-4af6-869b-097f8498140c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('f8e69081-3f87-4af6-869b-097f8498140c')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '5d344392-6d88-4988-aa67-baa37f2cfd74')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('5d344392-6d88-4988-aa67-baa37f2cfd74')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'fa52108b-8784-44a6-91fa-1d8db626bcff')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('fa52108b-8784-44a6-91fa-1d8db626bcff')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '02f784a5-d5bb-45f3-b23d-a811755a1876')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('02f784a5-d5bb-45f3-b23d-a811755a1876')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '59c438e2-452e-4014-aaa5-367225c127fa')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('59c438e2-452e-4014-aaa5-367225c127fa')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'db1c78cc-7140-445e-80b8-fb3d92d71bae')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('db1c78cc-7140-445e-80b8-fb3d92d71bae')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '28f80f4a-92ea-45ab-bd4e-d98659745fd4')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('28f80f4a-92ea-45ab-bd4e-d98659745fd4')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'c8c91fab-e57d-4eab-8211-c7d39d31bf8e')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('c8c91fab-e57d-4eab-8211-c7d39d31bf8e')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '3684f4bd-2f96-4956-9533-aa0f34ae46db')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('3684f4bd-2f96-4956-9533-aa0f34ae46db')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '26839b28-9d21-4538-af37-cf12b1df3492')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('26839b28-9d21-4538-af37-cf12b1df3492')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'e2e3cab2-7b76-429a-8884-6f0be08c1da7')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('e2e3cab2-7b76-429a-8884-6f0be08c1da7')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'a93dc6ed-315a-4b6f-868e-c1e4755d8021')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('a93dc6ed-315a-4b6f-868e-c1e4755d8021')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'c15e2aaf-3ee8-4db1-9e00-94a96f168a8d')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('c15e2aaf-3ee8-4db1-9e00-94a96f168a8d')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '5ef0b351-d59a-49ff-9373-424b394fb1ff')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('5ef0b351-d59a-49ff-9373-424b394fb1ff')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'ee8dfff2-2b20-4f8b-9ef1-0f01f07e4d18')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('ee8dfff2-2b20-4f8b-9ef1-0f01f07e4d18')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'fcd902dd-66b4-491a-9094-4d8f11320539')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('fcd902dd-66b4-491a-9094-4d8f11320539')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'c756332c-f9a4-478a-a293-ded51bad7a92')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('c756332c-f9a4-478a-a293-ded51bad7a92')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'c4d57ce9-ee6b-493c-8cce-1fdbf0d3fde3')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('c4d57ce9-ee6b-493c-8cce-1fdbf0d3fde3')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b518fead-f14f-41bc-9eb2-ba5f355306f2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b518fead-f14f-41bc-9eb2-ba5f355306f2')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'd60d038c-2b1a-4d5d-bb92-b5d60ed61b98')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('d60d038c-2b1a-4d5d-bb92-b5d60ed61b98')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'd5152b98-9a7a-4c98-b086-b35d4cba3ba6')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('d5152b98-9a7a-4c98-b086-b35d4cba3ba6')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '4e15e997-3aa5-4cf6-a3ff-d918d7c47707')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('4e15e997-3aa5-4cf6-a3ff-d918d7c47707')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b48a64cd-6751-4ceb-9fa1-a739489f0407')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b48a64cd-6751-4ceb-9fa1-a739489f0407')

GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[ShiftLogSignOff] WITH CHECK CHECK CONSTRAINT [FK_ShiftLogSignOff_ShiftLog];

ALTER TABLE [dbo].[ShiftLog] WITH CHECK CHECK CONSTRAINT [FK_ShiftLog_PreviousShiftLog];

ALTER TABLE [dbo].[ShiftLogBreak] WITH CHECK CHECK CONSTRAINT [FK_ShiftLogBreak_ShiftLog];

ALTER TABLE [target].[Daily] WITH CHECK CHECK CONSTRAINT [FK_TargetDaily_ShiftLog];

ALTER TABLE [dbo].[ShiftLog] WITH CHECK CHECK CONSTRAINT [FK_ShiftLog_Location];

ALTER TABLE [dbo].[ShiftLogSignOff] WITH CHECK CHECK CONSTRAINT [FK_ShiftLogSignOff_Line];

ALTER TABLE [dbo].[ShiftLogSignOff] WITH CHECK CHECK CONSTRAINT [FK_ShiftLogSignOff_SignedOffOperator];

ALTER TABLE [target].[Hourly] WITH CHECK CHECK CONSTRAINT [FK_TargetHourly_TargetDaily];

ALTER TABLE [target].[Daily] WITH CHECK CHECK CONSTRAINT [FK_TargetDaily_Type];

ALTER TABLE [target].[Daily] WITH CHECK CHECK CONSTRAINT [FK_TargetDaily_Line];

ALTER TABLE [target].[Daily] WITH CHECK CHECK CONSTRAINT [FK_TargetDaily_UpdateUser];

ALTER TABLE [target].[Hourly] WITH CHECK CHECK CONSTRAINT [FK_TargetHourly_UpdateUser];

ALTER TABLE [layout].[Workbench] WITH CHECK CHECK CONSTRAINT [FK_Workbench_Type];

ALTER TABLE [layout].[Workbench] WITH CHECK CHECK CONSTRAINT [FK_Workbench_Cell];

ALTER TABLE [layout].[Workbench] WITH CHECK CHECK CONSTRAINT [FK_Workbench_PreviousWorkbench];

ALTER TABLE [layout].[Line] WITH CHECK CHECK CONSTRAINT [FK_Line_Location];

ALTER TABLE [layout].[Cell] WITH CHECK CHECK CONSTRAINT [FK_Cell_Line];

ALTER TABLE [layout].[Monitor] WITH CHECK CHECK CONSTRAINT [FK_Monitor_Line];

ALTER TABLE [layout].[Monitor] WITH CHECK CHECK CONSTRAINT [FK_Monitor_Location];

ALTER TABLE [layout].[WorkbenchStatus] WITH CHECK CHECK CONSTRAINT [FK_WorkbenchStatus_Workbench];

ALTER TABLE [layout].[WorkbenchStatus] WITH CHECK CHECK CONSTRAINT [FK_WorkbenchStatus_ErrorId];

ALTER TABLE [layout].[LineTag] WITH CHECK CHECK CONSTRAINT [FK_LineTag_Line];

ALTER TABLE [log].[ProcedureLog] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLog_Procedure];

ALTER TABLE [users].[AccountToken] WITH CHECK CHECK CONSTRAINT [FK_AccountToken_Account];

ALTER TABLE [users].[AccountLoginHistory] WITH CHECK CHECK CONSTRAINT [FK_AccountLoginHistory_Account];

ALTER TABLE [users].[Account] WITH CHECK CHECK CONSTRAINT [FK_Account_AccountProvider];

ALTER TABLE [users].[Account] WITH CHECK CHECK CONSTRAINT [FK_Account_Profile];

ALTER TABLE [users].[Feature] WITH CHECK CHECK CONSTRAINT [FK_Feature_RequestorLevel];

ALTER TABLE [users].[Feature] WITH CHECK CHECK CONSTRAINT [FK_Feature_TargetLevel];

ALTER TABLE [users].[Feature] WITH CHECK CHECK CONSTRAINT [FK_Feature_UpdateUser];

ALTER TABLE [dbo].[Downtime] WITH CHECK CHECK CONSTRAINT [FK_Downtime_TargetHourly];

ALTER TABLE [dbo].[Downtime] WITH CHECK CHECK CONSTRAINT [FK_Downtime_Workbench];

ALTER TABLE [dbo].[DowntimeDetails] WITH CHECK CHECK CONSTRAINT [FK_DowntimeDetails_Downtime];

ALTER TABLE [target].[PartNumber] WITH CHECK CHECK CONSTRAINT [FK_TargetPartNumber_Daily];

ALTER TABLE [target].[PartNumber] WITH CHECK CHECK CONSTRAINT [FK_TargetPartNumber_LayoutPartNumber];

ALTER TABLE [target].[PartNumber] WITH CHECK CHECK CONSTRAINT [FK_TargetPartNumber_UpdateUser];

ALTER TABLE [ver].[Tables] WITH CHECK CHECK CONSTRAINT [FK_Tables_Version];

ALTER TABLE [dbo].[ShiftLog] WITH CHECK CHECK CONSTRAINT [CK_ShiftLog_PreviousShiftLogID];

ALTER TABLE [dbo].[ShiftLog] WITH CHECK CHECK CONSTRAINT [CK_ShiftLog_ShiftType];

ALTER TABLE [dbo].[ShiftLogBreak] WITH CHECK CHECK CONSTRAINT [CK_ShiftLogBreak_TimeEnd];

ALTER TABLE [target].[Daily] WITH CHECK CHECK CONSTRAINT [CK_TargetDaily_Value];

ALTER TABLE [target].[Hourly] WITH CHECK CHECK CONSTRAINT [CK_TargeHourly_Value];

ALTER TABLE [target].[Hourly] WITH CHECK CHECK CONSTRAINT [CK_TargetHourly_CumulativeValue];

ALTER TABLE [target].[Hourly] WITH CHECK CHECK CONSTRAINT [CK_TargetHourly_Hour];

ALTER TABLE [layout].[Monitor] WITH CHECK CHECK CONSTRAINT [CK_Monitor_IP];

ALTER TABLE [users].[Profile] WITH CHECK CHECK CONSTRAINT [CK_Profile_Operator];

ALTER TABLE [users].[Operator] WITH CHECK CHECK CONSTRAINT [CK_Operator_IsActive];

ALTER TABLE [users].[AccountLoginHistory] WITH CHECK CHECK CONSTRAINT [CK_AccountLoginHistory_LogouTime];

ALTER TABLE [users].[Feature] WITH CHECK CHECK CONSTRAINT [CK_Feature_RequestorLevelID];

ALTER TABLE [dbo].[Downtime] WITH CHECK CHECK CONSTRAINT [CK_Downtime_DataEnd];

ALTER TABLE [dbo].[DowntimeDetails] WITH CHECK CHECK CONSTRAINT [CK_DowntimeDetails_Duration];

ALTER TABLE [target].[PartNumber] WITH CHECK CHECK CONSTRAINT [CK_TargetPartNumber_Value];

ALTER TABLE [dbo].[BillboardLog] WITH CHECK CHECK CONSTRAINT [FK_Billboard_TargetHourly];

ALTER TABLE [dbo].[BillboardLog] WITH CHECK CHECK CONSTRAINT [CK_BillboardLog_ActualAchieved];

ALTER TABLE [dbo].[BillboardLog] WITH CHECK CHECK CONSTRAINT [CK_BillboardLog_CumulativeAchieved];

ALTER TABLE [dbo].[BillboardLog] WITH CHECK CHECK CONSTRAINT [CK_BillboardLog_Defects];

ALTER TABLE [dbo].[BillboardLog] WITH CHECK CHECK CONSTRAINT [CK_BillboardLog_Downtime];

ALTER TABLE [dbo].[BillboardLog] WITH CHECK CHECK CONSTRAINT [FK_Billboard_SignedOffOperator];


GO
PRINT N'Update complete.';


GO
