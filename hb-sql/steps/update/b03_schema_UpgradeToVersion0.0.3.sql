/*
Deployment script for MultiCodeBoard

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
--:setvar gitBaseFolder "C:\Developer\hb-docker\"
--:setvar __populateDatabase "True"
--:setvar relativeProjectPath "hb-sql\MultiCodeHourlyBoard\MultiCodeHourlyBoard"
--:setvar DatabaseName "MultiCodeBoard"
--:setvar DefaultFilePrefix "MultiCodeBoard"
--:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQL2012ENT\MSSQL\DATA\"
--:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQL2012ENT\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF;
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Dropping [dbo].[DF_ActualLog_UpdateDate]...';


GO
ALTER TABLE [dbo].[ActualsLog] DROP CONSTRAINT [DF_ActualLog_UpdateDate];


GO
PRINT N'Dropping [dbo].[DF_BillboardLog_UpdateDate]...';


GO
ALTER TABLE [dbo].[BillboardLog] DROP CONSTRAINT [DF_BillboardLog_UpdateDate];


GO
PRINT N'Dropping unnamed constraint on [import].[ActualsLogDeletedErrors]...';


GO
ALTER TABLE [import].[ActualsLogDeletedErrors] DROP CONSTRAINT [DF__ActualsLo__Delet__681373AD];


GO
PRINT N'Dropping unnamed constraint on [import].[ActualsLogErrors]...';


GO
ALTER TABLE [import].[ActualsLogErrors] DROP CONSTRAINT [DF__ActualsLo__TimeS__690797E6];


GO
PRINT N'Dropping unnamed constraint on [import].[ActualsLog]...';


GO
ALTER TABLE [import].[ActualsLog] DROP CONSTRAINT [DF__ActualsLo__TimeS__69FBBC1F];


GO
PRINT N'Dropping [import].[DF_ActualLog_UpdateDate]...';


GO
ALTER TABLE [import].[ActualsLogChanges] DROP CONSTRAINT [DF_ActualLog_UpdateDate];


GO
PRINT N'Dropping [layout].[DF_Order_DateIn]...';


GO
ALTER TABLE [layout].[WorkbenchStatus] DROP CONSTRAINT [DF_Order_DateIn];


GO
PRINT N'Dropping [log].[DF_ProcedureLog_TimeStamp]...';


GO
ALTER TABLE [log].[ProcedureLog] DROP CONSTRAINT [DF_ProcedureLog_TimeStamp];


GO
PRINT N'Dropping [users].[DF_Account_CreatedAt]...';


GO
ALTER TABLE [users].[Account] DROP CONSTRAINT [DF_Account_CreatedAt];


GO
PRINT N'Dropping [users].[DF_AccountToken_Expire]...';


GO
ALTER TABLE [users].[AccountToken] DROP CONSTRAINT [DF_AccountToken_Expire];


GO
PRINT N'Dropping [users].[DF_AccountToken_LoginTime]...';


GO
ALTER TABLE [users].[AccountToken] DROP CONSTRAINT [DF_AccountToken_LoginTime];


GO
PRINT N'Dropping [users].[DF_Operator_CreateTimeStamp]...';


GO
ALTER TABLE [users].[Operator] DROP CONSTRAINT [DF_Operator_CreateTimeStamp];


GO
PRINT N'Dropping [users].[DF_UserProfile_CreatedAt]...';


GO
ALTER TABLE [users].[Profile] DROP CONSTRAINT [DF_UserProfile_CreatedAt];


GO
PRINT N'Creating [global].[GetDateProxy]...';


GO
CREATE SYNONYM [global].[GetDateProxy] FOR [global].[GetSystemDate];


GO
PRINT N'Altering [dbo].[ShiftLogBreak_CheckTimeBetweenShiftLimits]...';


GO

ALTER TRIGGER [dbo].[ShiftLogBreak_CheckTimeBetweenShiftLimits]
ON [dbo].[ShiftLogBreak]
FOR INSERT, UPDATE
    AS
    BEGIN
        SET NoCount ON

		declare @time nvarchar(20)
		select top 1 @time = CONVERT(nvarchar(20), i.TimeStart, 120)
		from inserted i
			inner join dbo.vShiftLog sl on i.ShiftLogID = sl.ID
		where i.TimeStart < sl.DataStart
			or i.TimeStart >= sl.DataEnd

		if @time is not NULL
		begin
			rollback tran
			raiserror(N'Break start time %s is not in the time limit of associated shift.', 16, 1, @time)
		end

		select top 1 @time = CONVERT(nvarchar(20), i.TimeStart, 120)
		from inserted i
			inner join dbo.vShiftLog sl on i.ShiftLogID = sl.ID
		where i.TimeEnd < sl.DataStart
			or i.TimeEnd >= sl.DataEnd

		if @time is not NULL
		begin
			rollback tran
			raiserror(N'Break end time %s is not in the time limit of associated shift.', 16, 1, @time)
		end
    END
GO
PRINT N'Altering [global].[GetDate]...';


GO
ALTER FUNCTION [global].[GetDate]()
RETURNS [datetime]
AS
BEGIN
	return global.getDateProxy()
END
GO
PRINT N'Creating [dbo].[DF_ActualLog_UpdateDate]...';


GO
ALTER TABLE [dbo].[ActualsLog]
    ADD CONSTRAINT [DF_ActualLog_UpdateDate] DEFAULT ([global].[GetDate]()) FOR [AddDate];


GO
PRINT N'Creating [dbo].[DF_BillboardLog_UpdateDate]...';


GO
ALTER TABLE [dbo].[BillboardLog]
    ADD CONSTRAINT [DF_BillboardLog_UpdateDate] DEFAULT ([global].[GetDate]()) FOR [UpdateDate];


GO
PRINT N'Creating unnamed constraint on [import].[ActualsLogDeletedErrors]...';


GO
ALTER TABLE [import].[ActualsLogDeletedErrors]
    ADD DEFAULT ([global].[GetDate]()) FOR [DeleteDate];


GO
PRINT N'Creating unnamed constraint on [import].[ActualsLogErrors]...';


GO
ALTER TABLE [import].[ActualsLogErrors]
    ADD DEFAULT ([global].[GetDate]()) FOR [TimeStamp];


GO
PRINT N'Creating unnamed constraint on [import].[ActualsLog]...';


GO
ALTER TABLE [import].[ActualsLog]
    ADD DEFAULT ([global].[GetDate]()) FOR [TimeStamp];


GO
PRINT N'Creating [import].[DF_ActualLog_UpdateDate]...';


GO
ALTER TABLE [import].[ActualsLogChanges]
    ADD CONSTRAINT [DF_ActualLog_UpdateDate] DEFAULT ([global].[GetDate]()) FOR [AddDate];


GO
PRINT N'Creating [layout].[DF_Order_DateIn]...';


GO
ALTER TABLE [layout].[WorkbenchStatus]
    ADD CONSTRAINT [DF_Order_DateIn] DEFAULT ([global].[GetDate]()) FOR [LastChanged];


GO
PRINT N'Creating [log].[DF_ProcedureLog_TimeStamp]...';


GO
ALTER TABLE [log].[ProcedureLog]
    ADD CONSTRAINT [DF_ProcedureLog_TimeStamp] DEFAULT ([global].[GetDate]()) FOR [TimeStamp];


GO
PRINT N'Creating [users].[DF_Account_CreatedAt]...';


GO
ALTER TABLE [users].[Account]
    ADD CONSTRAINT [DF_Account_CreatedAt] DEFAULT ([global].[GetDate]()) FOR [CreatedAt];


GO
PRINT N'Creating [users].[DF_AccountToken_Expire]...';


GO
ALTER TABLE [users].[AccountToken]
    ADD CONSTRAINT [DF_AccountToken_Expire] DEFAULT (dateadd(minute,(60), [global].[GetDate]())) FOR [Expire];


GO
PRINT N'Creating [users].[DF_AccountToken_LoginTime]...';


GO
ALTER TABLE [users].[AccountToken]
    ADD CONSTRAINT [DF_AccountToken_LoginTime] DEFAULT ([global].[GetDate]()) FOR [LoginTime];


GO
PRINT N'Creating [users].[DF_Operator_CreateTimeStamp]...';


GO
ALTER TABLE [users].[Operator]
    ADD CONSTRAINT [DF_Operator_CreateTimeStamp] DEFAULT ([global].[GetDate]()) FOR [CreateTimeStamp];


GO
PRINT N'Creating [users].[DF_UserProfile_CreatedAt]...';


GO
ALTER TABLE [users].[Profile]
    ADD CONSTRAINT [DF_UserProfile_CreatedAt] DEFAULT (global.GetDate()) FOR [CreatedAt];


GO
PRINT N'Creating [global].[GetFixedDate]...';


GO
CREATE FUNCTION [global].[GetFixedDate]()
RETURNS DateTime AS
BEGIN
	declare @midnight datetime
	declare @millisecondsToday bigint
	declare @now datetime = getdate()

	select @midnight = DATEADD(day, DATEDIFF(day, 0, @now), 0)
	select @millisecondsToday = DATEDIFF(MILLISECOND, @midnight, @now)
	return DATEADD(MILLISECOND, @millisecondsToday, '2019-02-01')
END
GO
PRINT N'Creating [global].[GetSystemDate]...';


GO
CREATE FUNCTION [global].[GetSystemDate]()
RETURNS DATETIME AS
BEGIN
	RETURN GetDate()
END
GO
PRINT N'Altering [dbo].[SaveDowntime]...';


GO
/*
	Author/Date	:	Cristian Dinu, 10.08.2018
	Description	:	process edited downtime details
	LastChange	:
*/

ALTER PROCEDURE [dbo].[SaveDowntime]
	@TargetHourlyID int,
	@XML			XML,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint
	declare @txml table(
					ID			int,
					DowntimeID	int,
					Comment		nvarchar(100),
					Duration	smallint,
					[TimeStamp]	datetime)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, XMLParam)
	values(17, @XML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectTable = N'BillboardLog', @ObjectColumnID = N'TargetHourlyID', @ObjectID = @TargetHourlyID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get info from XML
		insert into @txml(ID, DowntimeID, Comment, Duration, [TimeStamp])
		select
			T.[Downtime].value('@id', 'int') as [ID],
			T.[Downtime].value('../../@id', 'int') as [DowntimeID],
			T.[Downtime].value('comment[1]', 'nvarchar(100)') as [Comment],
			T.[Downtime].value('duration[1]', 'smallint') as [Duration],
			CONVERT(datetime, T.[Downtime].value('@timeStamp', 'char(23)'), 121) as [TimeStamp]
		from @xml.nodes('//reason') as T([Downtime])

		-- checking zone
		-- if exist recent updates, after XML timestamp
		select top 1 @errorMessage = N'During current edit session another user started downtime details changes'
		from @txml
		where [TimeStamp] is not NULL
			and [TimeStamp] < (
				select MAX(dd.UpdateDate)
				from dbo.DowntimeDetails dd
					inner join dbo.Downtime d on dd.DowntimeID = d.ID
				where d.TargetHourlyID = @TargetHourlyID)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if there are empty fields
		select top 1 @errorMessage = N'There are records with missing DowntimeID values'
		from @txml
		where DowntimeID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Comment values'
		from @txml
		where Comment is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Duration values'
		from @txml
		where Duration is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if ID is correct
		select top 1 @errorMessage = N'There are records with incorrect DowntimeDetailsID values (e.g. ' + CONVERT(nvarchar(10), _t.ID) + N')'
		from @txml _t
			left join dbo.DowntimeDetails dd on _t.ID = dd.ID
			left join dbo.Downtime d on dd.DowntimeID = d.ID and d.TargetHourlyID = @TargetHourlyID
		where _t.ID is not NULL
			and d.ID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if DowntimeID is correct
		select top 1 @errorMessage = N'There are records with incorrect DowntimeID values (e.g. ' + CONVERT(nvarchar(10), DowntimeID) + N')'
		from @txml
		where DowntimeID not in (select ID from dbo.Downtime)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Duration is correct
		select top 1 @errorMessage = N'There are records with negative Duration values (e.g. ' + CONVERT(nvarchar(10), Duration) + N')'
		from @txml
		where Duration < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Duration is correct
		select top 1 @errorMessage = N'There are records with incorrect Duration values, greater than downtime interval (' + CONVERT(nvarchar(10), Duration) + N' minutes)'
		from @txml _t
			inner join dbo.Downtime d on _t.DowntimeID = d.ID
		where _t.Duration > DATEDIFF(MINUTE, d.DataStart, d.DataEnd)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- total duration <= downtime interval
		select top 1 @errorMessage = N'Total reasons duration (' + CONVERT(nvarchar(10), SUM(_t.Duration))
			+ N'min) is different than downtime total duration (' + CONVERT(nvarchar(10), DATEDIFF(MINUTE, d.DataStart, d.DataEnd)) + N'min)'
		from @txml _t
			inner join dbo.Downtime d on _t.DowntimeID = d.ID
		group by _t.DowntimeID, d.DataStart, d.DataEnd
		having SUM(_t.Duration) <> DATEDIFF(MINUTE, d.DataStart, d.DataEnd)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- data updates zone
		begin tran
			-- delete removed downtime details
			delete dd
			from dbo.DowntimeDetails dd
				inner join dbo.Downtime d on dd.DowntimeID = d.ID
			where d.TargetHourlyID = @TargetHourlyID
				and dd.ID not in (select ID from @txml)

			-- insert new downtime details
			insert into dbo.DowntimeDetails(DowntimeID, Comment, Duration, UpdateDate)
			select DowntimeID, Comment, Duration, [global].[GetDate]()
			from @txml
			where ID is NULL

			-- update downtime details
			update dd
			set Comment = _t.Comment,
				Duration = _t.Duration,
				UpdateDate = [global].[GetDate]()
			from dbo.DowntimeDetails dd
				inner join @txml _t on dd.ID = _t.ID
			where dd.Comment <> _t.Comment
				or dd.Duration <> _t.Duration
		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[GetBillboardv1]...';


GO
/*
Author/Date	:	Cristian Dinu, 13.01.2019
Description	:	get billboard data with recordset data
LastChange	:
*/

CREATE PROCEDURE [dbo].[GetBillboardv1]
	@MonitorID	int
AS
	set nocount on

	declare @targetDailyID	int,
			@shiftLogID	int,
			@lineID	smallint,
			@errorNumber	int = 16,
			@errorMessage	nvarchar(max),
			@procedureLogID	bigint

	declare @billboardLog table(
			TargetHourlyID	int,
			HourStart	datetime,
			HourEnd	datetime,
			[Hour]	tinyint,
			[HourInterval]	nchar(11),
			[Target]	smallint,
			CumulativeTarget	smallint,
			ActualAchieved	smallint,
			CumulativeAchieved	smallint,
			Defects	smallint,
			Downtime	int,
			Comment	nvarchar(100),
			Escalated	nvarchar(50),
			SignedOffOperatorID	int,
			SignedOffOperatorBarcode nvarchar(50))

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(11, N'@MonitorID=' + CONVERT(nvarchar(10), @MonitorID))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Monitor', @ObjectID = @MonitorID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get necessary informations for resulting xml dataset
		select top 1
			@targetDailyID = d.ID,
			@shiftLogID = slso.ShiftLogID,
			@lineID = m.LineID
		from layout.Monitor m
			cross join dbo.ShiftLog sl
			inner join dbo.ShiftLogSignOff slso on m.LineID = slso.LineID and sl.ID = slso.ShiftLogID
			left join [target].Daily d on m.LineID = d.LineID and slso.ShiftLogID = d.ShiftLogID
		where m.ID = @MonitorID
			and d.Billboard = 1
			and slso.SignedOffOperatorID is NULL
		order by sl.DataStart

		-- if target is missing there is no plan nor actuals values, all values are 0
		if @targetDailyID is NULL goto MissingTarget

		insert into @billboardLog(TargetHourlyID, HourStart, HourEnd, [Hour], [HourInterval], [Target], CumulativeTarget, ActualAchieved, CumulativeAchieved,
			Defects, Downtime, Comment, Escalated, SignedOffOperatorID, SignedOffOperatorBarcode)
		select TargetHourlyID, HourStart, HourEnd, [Hour], [HourInterval], [Target], CumulativeTarget, ActualAchieved, CumulativeAchieved,
			Defects, Downtime, Comment, Escalated, SignedOffOperatorID, SignedOffOperatorBarcode
		from vBillboardLog
		where TargetDailyID = @targetDailyID

		-- header info
		select
			CONVERT(nvarchar(10), sl.[Data], 20) 'date', sl.ShiftName 'shift',
			l.[Name] 'lineName', sl.LocationName 'locationName',
			CONVERT(decimal(6,2), ROUND((
				select CONVERT(decimal(10,2), MAX(CumulativeAchieved)) /
					CONVERT(decimal(10,2), case
						when MAX(HourEnd) < [global].[GetDate]() then 440
						when MIN(HourStart) = [global].[GetDate]() then 1
						else DATEDIFF(MINUTE, MIN([HourStart]), [global].[GetDate]()) / 12 * 11
					end)
				from @billboardLog
			), 2)) 'deliveryTime',
			(
				select MAX(ActualAchieved)
				from @billboardLog
			) 'maxHourProduction',
			slso.ID '@shiftLogSignOffID'
		from layout.Line l
			cross join dbo.vShiftLog sl
			inner join dbo.ShiftLogSignOff slso on l.ID = slso.LineID and sl.ID = slso.ShiftLogID
		where l.ID = @lineID
			and sl.ID = @shiftLogID

		-- table info
		select	bl.TargetHourlyID 'id',
			case when bl.SignedOffOperatorID is not NULL then 'yes' else 'no' end 'closed',
			case when fo.[Hour] is not NULL then 'yes' else 'no' end 'firstOpen',
			bl.HourInterval 'hourInterval', bl.[Target] 'target', bl.CumulativeTarget 'cumulativeTarget',
			bl.ActualAchieved 'achieved', bl.CumulativeAchieved 'cumulativeAchieved', bl.Defects 'defects',
			bl.Downtime 'downtime', bl.Comment 'comment', bl.Escalated 'escalated', bl.SignedOffOperatorBarcode 'signoff'
		from @billboardLog bl
			left join (
				select MIN([Hour]) [Hour]
				from @billboardLog
				where SignedOffOperatorID is NULL
			) fo on bl.[Hour] = fo.[Hour]
		order by bl.[Hour]
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage = ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

MissingTarget:
	set @errorMessage = N'Missing target on current shift or shift is closed'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [dbo].[SaveDowntimev1]...';


GO
/*
	Author/Date	:	Cristian Dinu, 25.01.2019
	Description	:	process edited downtime details with minimum input xml size
	LastChange	:

@XML example
<root>
   <reasons  downtimeid="140">
     <reason id="1" timeStamp="2019-01-24 00:57:13.680 ">
       <comment>Comment 1</comment>
       <duration>1</duration>
     </reason>
   </reasons>
   <reasons downtimeid="141">
     <reason id="2" timeStamp="2019-01-24 00:57:13.680 ">
       <comment>Comment 2</comment>
       <duration>2</duration>
     </reason>
     <reason id="3" timeStamp="2019-01-24 00:57:13.680 ">
       <comment>Comment 3</comment>
       <duration>3</duration>
     </reason>
   </reasons>
</root>'
*/

CREATE PROCEDURE [dbo].[SaveDowntimev1]
	@TargetHourlyID int,
	@XML			XML,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint
	declare @txml table(
					ID			int,
					DowntimeID	int,
					Comment		nvarchar(100),
					Duration	smallint,
					[TimeStamp]	datetime)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, XMLParam)
	values(17, @XML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectTable = N'BillboardLog', @ObjectColumnID = N'TargetHourlyID', @ObjectID = @TargetHourlyID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get info from XML
		insert into @txml(ID, DowntimeID, Comment, Duration, [TimeStamp])
		select
			T.[Downtime].value('@id', 'int') as [ID],
			T.[Downtime].value('../@downtimeid', 'int') as [DowntimeID],
			T.[Downtime].value('comment[1]', 'nvarchar(100)') as [Comment],
			T.[Downtime].value('duration[1]', 'smallint') as [Duration],
			CONVERT(datetime, T.[Downtime].value('@timeStamp', 'char(23)'), 121) as [TimeStamp]
		from @xml.nodes('//reason') as T([Downtime])

		-- checking zone
		-- if exist recent updates, after XML timestamp
		select top 1 @errorMessage = N'During current edit session another user started downtime details changes'
		from @txml
		where ID <> 0
			and [TimeStamp] < (
				select MAX(dd.UpdateDate)
				from dbo.DowntimeDetails dd
					inner join dbo.Downtime d on dd.DowntimeID = d.ID
				where d.TargetHourlyID = @TargetHourlyID
			)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if there are empty fields
		select top 1 @errorMessage = N'There are records with missing DowntimeID values'
		from @txml
		where DowntimeID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Comment values'
		from @txml
		where Comment is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Duration values'
		from @txml
		where Duration is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if ID is correct
		select top 1 @errorMessage = N'There are records with incorrect DowntimeDetailsID values (e.g. ' + CONVERT(nvarchar(10), _t.ID) + N')'
		from @txml _t
			left join dbo.DowntimeDetails dd on _t.ID = dd.ID
			left join dbo.Downtime d on dd.DowntimeID = d.ID and d.TargetHourlyID = @TargetHourlyID
		where _t.ID > 0
			and d.ID is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if DowntimeID is correct
		select top 1 @errorMessage = N'There are records with incorrect DowntimeID values (e.g. ' + CONVERT(nvarchar(10), DowntimeID) + N')'
		from @txml
		where DowntimeID not in (select ID from dbo.Downtime)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Duration is correct
		select top 1 @errorMessage = N'There are records with negative Duration values (e.g. ' + CONVERT(nvarchar(10), Duration) + N')'
		from @txml
		where Duration < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Duration is correct
		select top 1 @errorMessage = N'There are records with incorrect Duration values, greater than downtime interval (' + CONVERT(nvarchar(10), Duration) + N' minutes)'
		from @txml _t
			inner join dbo.Downtime d on _t.DowntimeID = d.ID
		where _t.Duration > DATEDIFF(MINUTE, d.DataStart, d.DataEnd)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- total duration <= downtime interval
		select top 1 @errorMessage = N'Total reasons duration (' + CONVERT(nvarchar(10), SUM(_t.Duration))
			+ N'min) is different than downtime total duration (' + CONVERT(nvarchar(10), DATEDIFF(MINUTE, d.DataStart, d.DataEnd)) + N'min)'
		from @txml _t
			inner join dbo.Downtime d on _t.DowntimeID = d.ID
		group by _t.DowntimeID, d.DataStart, d.DataEnd
		having SUM(_t.Duration) <> DATEDIFF(MINUTE, d.DataStart, d.DataEnd)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- data updates zone
		begin tran
			-- delete removed downtime details
			delete dd
			from dbo.DowntimeDetails dd
				inner join dbo.Downtime d on dd.DowntimeID = d.ID
			where d.TargetHourlyID = @TargetHourlyID
				and dd.ID not in (select ID from @txml where ID > 0)

			-- insert new downtime details
			insert into dbo.DowntimeDetails(DowntimeID, Comment, Duration, UpdateDate)
			select DowntimeID, Comment, Duration, [global].[GetDate]()
			from @txml
			where ID = 0

			-- update downtime details
			update dd
			set Comment = _t.Comment,
				Duration = _t.Duration,
				UpdateDate = [global].[GetDate]()
			from dbo.DowntimeDetails dd
				inner join @txml _t on dd.ID = _t.ID
			where _t.ID > 0
				and (dd.Comment <> _t.Comment or dd.Duration <> _t.Duration)
		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[AddTargetAutomaticv1]...';


GO
/*
	Author/Date	:	Cristian Dinu, 08.02.2019
	Description	:	add target for specific date all lines, all shifts, only for
	LastChange	:
*/


CREATE PROCEDURE [target].[AddTargetAutomaticv1]
	@Data	datetime
as
	set nocount on

	declare @autoUserID			int = users.AutomaticOperator(),
			@errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint
	declare @daily table(LineID int, TypeID char(2), ShiftLogID int, [Value] smallint, PreviousDailyID int)
	declare @hours table([Hour] tinyint)
	declare @dailyIDs idTable


	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(25,
		N'@Data=' + ISNULL(CONVERT(nvarchar(10), @Data, 105), N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	insert into @daily(LineID, TypeID, ShiftLogID, [Value], PreviousDailyID)
	select l.ID, pd.TypeID, sl.ID, pd.[Value], ld.DailyID
	from layout.Line l
		cross join dbo.ShiftLog sl
		left join [target].vDaily vd on l.ID = vd.LineID and sl.ID = vd.ShiftLogID and vd.Billboard = 1
		-- last existing target on previous week day of @data
		left join (
			select LineID, ShiftType, MAX(ID) DailyID
			from [target].vDaily
			where [Data] < @Data
				and Billboard = 1
				and DATEPART(WEEKDAY, [Data]) = DATEPART(WEEKDAY, @Data)
			group by LineID, ShiftType
		) ld on l.ID = ld.LineID and sl.ShiftType = ld.ShiftType
		left join [target].vDaily pd on ld.DailyID = pd.ID
	where l.Deleted = 0
		and sl.Data = @Data
		and vd.ID is NULL

	begin try
		begin tran
			-- insert target from previous day-week, if any
			insert into [target].Daily(TypeID, LineID, ShiftLogID, [Value], UpdateUserID, UpdateDate)
			select TypeID, LineID, ShiftLogID, [Value], @autoUserID, [global].[GetDate]()
			from @daily
			where PreviousDailyID is not NULL

			if @@ROWCOUNT <> 0
			begin
				insert into [target].Hourly(DailyID, [Hour], [Value], CumulativeValue, UpdateUserID, UpdateDate)
				select vd.ID, vh.[Hour], vh.HourlyTarget, vh.HourlyCumulativeTarget, vd.UpdateUserID, vd.UpdateDate
				from [target].vHourly vh
					inner join [target].vDaily vd on vh.LineID = vd.LineID and vh.TypeID = vd.TypeID and vh.ShiftType = vd.ShiftType
				where vh.DailyID in (select PreviousDailyID from @daily)
					and vd.[Data] = @Data

				insert into [target].[PartNumber](DailyID, PartNumberID, [Priority], InitialQty, [Value], UpdateUserID, UpdateDate)
				select vd.ID, pn.PartNumberID, pn.[Priority], pn.InitialQty, pn.[Value], vd.UpdateUserID, vd.UpdateDate
				from [target].[PartNumber] pn
					inner join [target].vDaily vpd on pn.DailyID = vpd.ID
					inner join [target].vDaily vd on vpd.LineID = vd.LineID and vpd.TypeID = vd.TypeID and vpd.ShiftType = vd.ShiftType
				where pn.DailyID in (select PreviousDailyID from @daily)
					and vd.[Data] = @Data
			end

			-- insert new target with 0 value
			insert into [target].Daily(TypeID, LineID, ShiftLogID, [Value], UpdateUserID, UpdateDate)
			select 'DY', LineID, ShiftLogID, 0, @autoUserID, [global].[GetDate]()
			from @daily
			where PreviousDailyID is NULL

			-- add hourly 0 values
			if @@ROWCOUNT <> 0
			begin
				insert into @hours([Hour]) values (1), (2), (3), (4), (5), (6), (7), (8)

				insert into [target].Hourly(DailyID, [Hour], [Value], CumulativeValue, UpdateUserID, UpdateDate)
				select d.ID, _h.[Hour], 0, 0, @autoUserID, [global].[GetDate]()
				from @hours _h
					cross join @daily _d
					inner join [target].Daily d on _d.LineID = d.LineID and _d.TypeID = d.TypeID
				where _d.PreviousDailyID is NULL
			end

			-- set new target in billboard
			insert into @dailyIDs
			select ID
			from [target].vDaily
			where [Data] = @Data
				and UpdateUserID = @autoUserID

			exec [target].[SetBillboardOnByIDList] @UserID = @autoUserID, @DailyIDs = @dailyIDs

		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch

return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Creating [target].[GetPlanningDataSetsv1]...';

GO
/*
	@filtersXML:
	<root>
	 <lines><line>1</line><line>2</line></lines>
	 <dates><date>2019-02-13</date><date>2019-02-14</date></dates>
	</root>
*/


CREATE PROCEDURE [target].[GetPlanningDataSetsv1]
	@UserID		int,
	@FiltersXML	XML, 
	@TargetsXML	XML	OUTPUT,
	@errorMessage nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@procedureLogID		bigint,
			@timeOut			smallint,
			@nextMonday			datetime
	declare @lines	table(LineID int)
	declare @dates	table([Data] datetime) 

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID)
	values(7, @UserID)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		exec [global].GetSettingKeyValue @Key = N'SESSION_EXPIRES_IN_MINUTES', @ProcedureLogID = @procedureLogID, @Value = @timeOut OUTPUT
		set @nextMonday = [global].NextMonday([global].[GetDate]())

		-- get info from XML
		insert into @lines(LineID)
		select
			T.[lines].value('.', 'int') as [Value]
		from @FiltersXML.nodes('//line') as T([lines])

		insert into @dates([Data])
		select
			T.[dates].value('.', 'datetime') as [Value]
		from @FiltersXML.nodes('//date') as T([dates])

		set @TargetsXML = (
			select CONVERT(char(23), [global].[GetDate](), 121) [timeStamp], @timeout [timeOut],
				CONVERT(nvarchar(10), @nextMonday, 120) + N' Shift A' [startingWith], 
				(
					select d.ID '@dailyTargetID', d.LocationID '@location', l.Tags '@tags',
						case when slso.SignedOffOperatorID is NULL then 'Yes' else 'No' end '@open',
						d.LineID 'line/@id', l.[Name] line, CONVERT(nvarchar(10), d.[Data], 120) [date], d.ShiftType [shift],
						d.TypeID [type], case d.Billboard when 1 then 'Yes' else 'No' end [billboard],
						h1.[Value] qtyHour_1, h2.[Value] qtyHour_2, h3.[Value] qtyHour_3,
						h4.[Value] qtyHour_4, h5.[Value] qtyHour_5, h6.[Value] qtyHour_6,
						h7.[Value] qtyHour_7, h8.[Value] qtyHour_8, d.[Value] qtyTotal
					from [target].vDaily d
						left join dbo.ShiftLogSignOff slso on d.LineID = slso.LineID and d.ShiftLogID = slso.ShiftLogID
						inner join layout.Line l on d.LineID = l.ID
						left join [target].Hourly h1 on d.ID = h1.DailyID and h1.[Hour] = 1
						left join [target].Hourly h2 on d.ID = h2.DailyID and h2.[Hour] = 2
						left join [target].Hourly h3 on d.ID = h3.DailyID and h3.[Hour] = 3
						left join [target].Hourly h4 on d.ID = h4.DailyID and h4.[Hour] = 4
						left join [target].Hourly h5 on d.ID = h5.DailyID and h5.[Hour] = 5
						left join [target].Hourly h6 on d.ID = h6.DailyID and h6.[Hour] = 6
						left join [target].Hourly h7 on d.ID = h7.DailyID and h7.[Hour] = 7
						left join [target].Hourly h8 on d.ID = h8.DailyID and h8.[Hour] = 8
					where d.LineID in (select LineID from @lines)
						and d.[Data] in (select [Data] from @dates) 
					order by d.LocationID, l.[Name], d.[Data], d.TypeID, d.ShiftType
					for xml path('row'), type, ELEMENTS XSINIL)
			for xml path('root'), type)
		if @@ROWCOUNT = 0 goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @TargetsXML
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO

PRINT N'Altering [target].[AddTargetAutomatic]...';


GO
/*
	Author/Date	:	Cristian Dinu, 29.08.2018
	Description	:	add target for specific Line + Shift
	LastChange	:
*/

ALTER PROCEDURE [target].[AddTargetAutomatic]
	@LineID			int,
	@ShiftLogID		int,
	@DailyID		int OUTPUT
as
	set nocount on

	declare @autoUserID			int = users.AutomaticOperator(),
			@previousdDailyID	int,
			@typeID				char(2),
			@errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint
	declare @hours table([Hour] tinyint)
	declare @dailyIDs idTable


	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(25,
		N'@LineID=' + ISNULL(CONVERT(nvarchar(10), @LineID), N'NULL') + N', ' +
		N'@ShiftLogID=' + ISNULL(CONVERT(nvarchar(10), @ShiftLogID), N'NULL'))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		begin tran

			-- insert target from previous day-week, if any
			select top 1
				@previousdDailyID = vd.ID,
				@typeID = vd.TypeID
			from [target].vDaily vd
				cross join dbo.ShiftLog sl
			where vd.LineID = @LineID
				and vd.Billboard = 1
				and vd.[Data] < [global].GetDate()
				and sl.ID = @ShiftLogID
				and DATEPART(WEEKDAY, vd.[Data]) = DATEPART(WEEKDAY, sl.[Data])
			order by vd.[Data] desc

			if @@ROWCOUNT <> 0
			begin
				insert into [target].Daily(TypeID, LineID, ShiftLogID, [Value], UpdateUserID, UpdateDate)
				select TypeID, LineID, ShiftLogID, [Value], @autoUserID, [global].[GetDate]()
				from [target].Daily
				where ID = @previousdDailyID
				set @DailyID = SCOPE_IDENTITY()

				insert into [target].Hourly(DailyID, [Hour], [Value], CumulativeValue, UpdateUserID, UpdateDate)
				select @DailyID, [Hour], 0, 0, @autoUserID, [global].[GetDate]()
				from [target].Hourly
				where DailyID = @previousdDailyID

				if @typeID = 'PN'
					insert into [target].[PartNumber](DailyID, PartNumberID, [Priority], InitialQty, [Value], UpdateUserID, UpdateDate)
					select @DailyID, PartNumberID, [Priority], InitialQty, [Value], UpdateUserID, UpdateDate
					from [target].[PartNumber]
					where DailyID = @DailyID
			end
			else
			begin
				-- insert new target with 0 value
				insert into [target].Daily(TypeID, LineID, ShiftLogID, [Value], UpdateUserID, UpdateDate)
				values('DY', @LineID, @ShiftLogID, 0, @autoUserID, [global].[GetDate]())
				set @DailyID = SCOPE_IDENTITY()

				-- add hourly 0 values
				insert into @hours([Hour]) values (1), (2), (3), (4), (5), (6), (7), (8)

				insert into [target].Hourly(DailyID, [Hour], [Value], CumulativeValue, UpdateUserID, UpdateDate)
				select @DailyID, [Hour], 0, 0, @autoUserID, [global].[GetDate]()
				from @hours
			end

			-- set new target in billboard
			insert into @dailyIDs(ID) values(@DailyID)
			exec [target].[SetBillboardOnByIDList] @UserID = @autoUserID, @DailyIDs = @dailyIDs

		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch

return(0)

ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Altering [target].[SaveTargetByPartNumber]...';


GO
/*
	Author/Date	:	Cristian Dinu, 10.09.2018
	Description	:	process targets by partnumber data set
	LastChange	:
*/

ALTER PROCEDURE [target].[SaveTargetByPartNumber]
	@UserID			int,
	@TargetsXML		XML,
	@errorMessage	nvarchar(max) OUTPUT
AS
	set nocount on

	declare @errorNumber		int = 16,
			@timeStamp			datetime,
			@procedureLogID		bigint,
			@sDate				varchar(50),
			@date				datetime,
			@lineID				int,
			@capacity			smallint,
			@eolMachines		smallint,
			@editMode			tinyint	= 0 -- 0=new, 1=edit
	declare @txml_pn table(
					[Priority]	smallint,
					PartNumber	nvarchar(50),
					InitialQty	int,
					Totals		int,
					ShiftType	char(1),
					[Value]		int)
	declare @txml_hour table(
					[Hour]			tinyint,
					ShiftType		char(1),
					[Value]			int)

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, ProfileID, XMLParam)
	values(21, @UserID, @TargetsXML)
	select @procedureLogID = SCOPE_IDENTITY()

	begin try
		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'users', @ObjectTable = N'Profile', @ObjectID = @UserID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get info from XML
		select @lineID = T.[targets].value('line[1]/@id', 'int'),
				@sDate = T.[targets].value('date[1]', 'char(10)'),
				@timeStamp = CONVERT(datetime, T.[targets].value('timeStamp[1]', 'char(23)'), 121)
		from @TargetsXML.nodes('//root') as T([targets])
		if @@ROWCOUNT = 0 goto WrongXML

		-- check if LineID is valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Line', @ObjectID = @lineID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID
		-- check if Data is correct
		if ISDATE(@sDate) = 0 goto IncorrectDate
		else set @date = CONVERT(datetime, @sDate, 120)

		-- get Line info
		select @capacity = capacity,
				@eolMachines = eolMachines
		from layout.vActiveLines
		where id = @lineID

		-- get rows from XML
		insert into @txml_pn([Priority], PartNumber, InitialQty, Totals, ShiftType, [Value])
		select
			T.[targets].value('../../@priority', 'smallint') as [Priority],
			T.[targets].value('../../partNumber[1]', 'nvarchar(50)') as [PartNumber],
			T.[targets].value('../../initialQuantity[1]', 'int') as [InitialQty],
			T.[targets].value('../../totals[1]', 'int') as [Totals],
			T.[targets].value('@name', 'char(1)') as [ShiftType],
			ISNULL(T.[targets].value('.', 'int'), 0) as [Value]
		from @TargetsXML.nodes('//shifts/shift') as T([targets])
		order by [Priority]
		if @@ROWCOUNT = 0 goto WrongXML

		insert into @txml_hour([Hour], ShiftType, [Value])
		select
			T.[targets].value('@interval', 'tinyint') as [Hour],
			T.[targets].value('../@name', 'char(1)') as [ShiftType],
			ISNULL(T.[targets].value('.', 'int'), 0) as [Value]
		from @TargetsXML.nodes('//dataset/shift/hour') as T([targets])
		if @@ROWCOUNT = 0 goto WrongXML

		-- add TargetDaily/HourlyID information
		-- id is not saved in XML because in web form <hour> elements can be deleted and recreated

		-- identify what is current and new planning status
		-- 0 = no current line+date combination, new datasets should be generated
		-- 1 = line+date combination already exists, existing dataset will be recreated
		select @editMode = 1
		from [target].vDaily
		where TypeID = 'PN'
			and LineID = @lineID
			and [Data] = @date

		-- checking zone
		-- if exist recent updates, after XML timestamp
		select top 1 @errorMessage = N'During current edit session another user started targets changes session'
		from [target].PartNumber pn
			inner join [target].vDaily d on pn.DailyID = d.ID
		where d.LineID = @LineID
			and d.[Data] = @Date
			and pn.UpdateDate > @timeStamp
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'During current edit session another user started targets changes session'
		from [target].vHourly
		where LineID = @LineID
			and ShiftData = @Date
			and UpdateDate > @timeStamp
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- if there are empty fields
		select top 1 @errorMessage = N'There are records with missing Priority values'
		from @txml_pn
		where [Priority] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing PartNumber values'
		from @txml_pn
		where PartNumber is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing InitialQuantity values'
		from @txml_pn
		where InitialQty is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Totals values'
		from @txml_pn
		where Totals is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing PartNumber.ShiftType values'
		from @txml_pn
		where ShiftType is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing PartNumber target values'
		from @txml_pn
		where [Value] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Hourly.Interval values'
		from @txml_hour
		where [Hour] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Hourly.ShiftType values'
		from @txml_hour
		where ShiftType is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with missing Hourly target values'
		from @txml_hour
		where [Value] is NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if PartNumber.ShiftType record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect PartNumber.ShiftType values (e.g. ' + ShiftType + N')'
		from @txml_pn
		where ShiftType not in ('A', 'B', 'C')
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly.Hour record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect Hourly.Interval values (e.g. shift ' + ShiftType + N', interval ' + CONVERT(nvarchar(10), [Hour]) + N')'
		from @txml_hour
		where [Hour] not between 1 and 8
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Priority record is doubled
		select top 1 @errorMessage = N'There are edited records with doubled PartNumber.Priority values (e.g. shift ' + ShiftType + N', Priority ' + CONVERT(nvarchar(10), [Priority]) + N')'
		from @txml_pn
		group by ShiftType, [Priority]
		having COUNT(*) > 1
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly.Hour record is doubled
		select top 1 @errorMessage = N'There are edited records with doubled Hourly.Interval values (e.g. shift ' + ShiftType + N', interval ' + CONVERT(nvarchar(10), [Hour]) + N')'
		from @txml_hour
		group by ShiftType, [Hour]
		having COUNT(*) > 1
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly.ShiftType record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect Hour.ShiftType values (e.g. ' + ShiftType + N')'
		from @txml_hour
		where ShiftType not in ('A', 'B', 'C')
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if PartNumber record is correct
		select top 1 @errorMessage = N'There are edited records with incorrect PartNumber values (e.g. ' + PartNumber + N')'
		from @txml_pn
		where PartNumber not in (select PartNumber from layout.PartNumber)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if quantity values are correct
		select top 1 @errorMessage = N'There are records with negative InitialQuantity values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where InitialQty < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with negative Totals values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where Totals < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with negative PartNumber/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where [Value] < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with negative Hour/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_hour
		where [Value] < 0
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if quantity values are too big
		select top 1 @errorMessage = N'There are records with too big InitialQuantity values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where InitialQty > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with too big Totals values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where Totals > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with too big PartNumber/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_pn
		where [Value] > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		select top 1 @errorMessage = N'There are records with too big Hour/Target values (e.g. ' + CONVERT(nvarchar(10), [Value]) + N')'
		from @txml_hour
		where [Value] > 32000
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if there are missing/dubled Hourly values (should be 8 / shift)
		select top 1 @errorMessage = N'There are shifts with incorrect number of hourly target values per shift (e.g. ' + ShiftType + N' with ' + CONVERT(nvarchar(10), COUNT([Value])) +  N')'
		from @txml_hour
		group by ShiftType
		having COUNT([Value]) <> 8
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Total is equal with InitialQuantity
		select top 1 @errorMessage = N'There are PartNumbers where Totals value is different then InitialQuantity value (e.g. ' + PartNumber + N')'
		from @txml_pn
		where Totals <> InitialQty
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if target values sum is equal with Totals for each PartNumber
		select top 1 @errorMessage = N'There are PartNumbers where Totals value is different then shift target values sum (e.g. ' + PartNumber + N')'
		from @txml_pn
		group by PartNumber, Totals
		having Totals <> SUM([Value])
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if Hourly target values sum is equal with PartNumber target values sum
		select top 1 @errorMessage = N'Total value for PartNumber split (' + CONVERT(nvarchar(10), _pn.Totals)
			+ N') is different then total values for Hourly split (' + CONVERT(nvarchar(10), _hour.Totals) + N') '
		from (
				select SUM([Value]) Totals
				from @txml_pn) _pn,
			(
				select SUM([Value]) Totals
				from @txml_hour) _hour
		where _pn.Totals <> _hour.Totals
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if PartNumber target values sum is equal with Hourly target values sum for each shift type
		select top 1 @errorMessage = N'There are shifts where PartNumber target values sum is different than Hourly target values sum (e.g. '
			+ st.ShiftType + N', Total PartNumber = ' + CONVERT(nvarchar(10), ISNULL(_pn.Totals, 0))
			+ N', Total Hourly = ' + CONVERT(nvarchar(10), ISNULL(_hour.Totals, 0)) + N')'
		from (
			select ShiftType
			from dbo.ShiftLog
			where [Data] = @Date
		) st
			left join (
				select ShiftType, SUM([Value]) Totals
				from @txml_pn
				group by ShiftType
			) _pn on st.ShiftType = _pn.ShiftType
			left join (
				select ShiftType, SUM([Value]) Totals
				from @txml_hour
				group by ShiftType
			) _hour on st.ShiftType = _hour.ShiftType
		where ISNULL(_pn.Totals, 0) <> ISNULL(_hour.Totals, 0)
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if shifts are open
		select top 1 @errorMessage = N'Target values for shift ' + _h.ShiftType + N' cannot be saved because is closed'
		from @txml_hour _h
			inner join dbo.ShiftLog sl on _h.ShiftType = sl.ShiftType
			left join dbo.ShiftLogSignOff slso on sl.ID = slso.ShiftLogID
		where sl.[Data] = @date
			and slso.LineID = @lineID
			and slso.SignedOffOperatorID is not NULL
		if @@ROWCOUNT <> 0 goto ErrorExit

		-- check if target match line capacity
		select top 1 @errorMessage = N'Total target values for shift ' + ShiftType
			+ N' (' + CONVERT(varchar(10), SUM([Value])) + N') exceed the line capacity (' + CONVERT(varchar(10), @capacity) + ')'
		from @txml_hour
		group by ShiftType
		having SUM([Value]) > @capacity

		-- check if target match PartNumber routing
		select top 1 @errorMessage = N'Total production time for shift '
			+ ShiftType + N', based on partnumber target values and routings (' + CONVERT(varchar(10), SUM(_pn.[Value] * pn.Routing))
			+ N' min) exceed shift time frame and line layout (440 minutes x ' + CONVERT(varchar(10), @eolMachines) + ' EOL Machines)'
		from @txml_pn _pn
			inner join layout.PartNumber pn on _pn.PartNumber = pn.PartNumber
		group by ShiftType
		having SUM(_pn.[Value] * pn.Routing) > 440 * @eolMachines

		-- data updates zone
		begin tran
			-- new planning datasets
			if @editMode = 0
			begin
				insert into [target].Daily(TypeID, LineID, ShiftLogID, [Value], UpdateUserID, UpdateDate)
				select 'PN', @LineID, sl.ID, SUM([Value]), @UserID, [global].[GetDate]()
				from @txml_hour _h
					inner join dbo.ShiftLog sl on _h.ShiftType = sl.ShiftType and sl.[Data] = @Date
				group by sl.ID

				-- part number target values
				insert into [target].PartNumber(DailyID, PartNumberID, [Priority], InitialQty, [Value], UpdateUserID, UpdateDate)
				select d.ID, pn.ID, _pn.[Priority],
					case when _pn.ShiftType = 'A' then _pn.InitialQty else 0 end,
					_pn.[Value], @UserID, [global].[GetDate]()
				from @txml_pn _pn
					inner join [target].vDaily d on _pn.ShiftType = d.ShiftType
					inner join layout.PartNumber pn on _pn.PartNumber = pn.PartNumber
				where  d.TypeID = 'PN'
					and d.LineID = @LineID
					and d.[Data] = @date

				-- hourly target values
				insert into [target].Hourly(DailyID, [Hour], [Value], CumulativeValue, UpdateUserID, UpdateDate)
				select d.ID, [Hour], _h.[Value], _h.[Value], @UserID, [global].[GetDate]()
				from @txml_hour _h
					inner join [target].vDaily d on _h.ShiftType = d.ShiftType
				where  d.TypeID = 'PN'
					and d.LineID = @LineID
					and d.[Data] = @date

				-- set target on billboard if new records are the first on LineID + Date combination
				declare @dailyIDs idTable

				insert into @dailyIDs(ID)
				select MIN(d.ID)
				from [target].Daily d
					left join [target].Daily dd on d.LineID = dd.LineID and d.ShiftLogID = dd.ShiftLogID and d.ID <> dd.ID
				where d.Billboard = 0
					and dd.ID is NULL
				group by d.LineID, d.ShiftLogID

				if @@ROWCOUNT > 0
					exec [target].[SetBillboardOnByIDList] @UserID = @UserID, @DailyIDs = @dailyIDs
			end

			-- existing planning datasets
			else
			begin
				-- part numbers target values
				-- existing records
				update tpn
				set [InitialQty] = case when _pn.ShiftType = 'A' then _pn.InitialQty else 0 end,
					[PartNumberID] = lpn.ID,
					[Value] = _pn.[Value],
					UpdateUseriD = @UserID,
					UpdateDate = [global].[GetDate]()
				from @txml_pn _pn
					inner join [target].vDaily d on _pn.ShiftType = d.ShiftType
					inner join [target].PartNumber tpn on d.ID = tpn.DailyID and _pn.[Priority] = tpn.[Priority]
					inner join layout.PartNumber lpn on _pn.PartNumber = lpn.PartNumber
				where  d.TypeID = 'PN'
					and d.LineID = @LineID
					and d.[Data] = @date
					and (tpn.PartNumberID <> lpn.ID or tpn.[Value] <> _pn.[Value])

				-- new records
				insert into [target].PartNumber(DailyID, PartNumberID, [Priority], InitialQty, [Value], UpdateUserID, UpdateDate)
				select d.ID, lpn.ID, _pn.[Priority],
					case when _pn.ShiftType = 'A' then _pn.InitialQty else 0 end,
					_pn.[Value], @UserID, [global].[GetDate]()
				from @txml_pn _pn
					inner join [target].vDaily d on _pn.ShiftType = d.ShiftType
					left join [target].PartNumber tpn on d.ID = tpn.DailyID and _pn.[Priority] = tpn.[Priority]
					inner join layout.PartNumber lpn on _pn.PartNumber = lpn.PartNumber
				where  d.TypeID = 'PN'
					and d.LineID = @LineID
					and d.[Data] = @date
					and tpn.ID is NULL

				-- delete missing records
				delete tpn
				from [target].PartNumber tpn
					inner join [target].vDaily d on tpn.DailyID = d.ID
					left join @txml_pn _pn on tpn.DailyID = d.ID and tpn.[Priority] = _pn.[Priority]
				where  d.TypeID = 'PN'
					and d.LineID = @LineID
					and d.[Data] = @date
					and _pn.[Priority] is NULL

				-- hourly target values
				update h
				set [Value] = _h.[Value],
					CumulativeValue = _h.[Value],
					UpdateUseriD = @UserID,
					UpdateDate = [global].[GetDate]()
				from @txml_hour _h
					inner join [target].vDaily d on _h.ShiftType = d.ShiftType
					inner join [target].Hourly h on d.ID = h.DailyID and _h.[Hour] = h.[Hour]
				where  d.TypeID = 'PN'
					and d.LineID = @LineID
					and d.[Data] = @date
					and h.[Value] <> _h.[Value]
			end

		if @@TRANCOUNT > 0 commit tran

	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		if @@TRANCOUNT > 0 rollback tran
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
	goto ErrorExit
WrongXML:
	set @errorMessage = N'Wrong XML dataset'
	goto ErrorExit
IncorrectDate:
	set @errorMessage = N'Wrong Date value (' + @Date + N')'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Altering [dbo].[GetBillboard]...';


GO
/*
	Author/Date	:	Cristian Dinu, 07.08.2018
	Description	:	get billboard data with XML data
	LastChange	:
*/

ALTER PROCEDURE [dbo].[GetBillboard]
	@MonitorID	int,
	@XML		XML OUTPUT
AS
	set nocount on

	declare @targetDailyID		int,
			@shiftLogID			int,
			@lineID				smallint,
			@errorNumber		int = 16,
			@errorMessage		nvarchar(max),
			@procedureLogID		bigint
	declare @billboardLog table(
							TargetHourlyID		int,
							HourStart			datetime,
							HourEnd				datetime,
							[Hour]				tinyint,
							[HourInterval]		nchar(11),
							[Target]			smallint,
							CumulativeTarget	smallint,
							ActualAchieved		smallint,
							CumulativeAchieved	smallint,
							Defects				smallint,
							Downtime			int,
							Comment				nvarchar(100),
							Escalated			nvarchar(50),
							SignedOffOperatorID	int,
							SignedOffOperatorBarcode nvarchar(50))

	-- log procedure exec
	insert into [log].ProcedureLog(ProcedureID, CustomParams)
	values(11, N'@MonitorID=' + CONVERT(nvarchar(10), @MonitorID))
	select @procedureLogID = SCOPE_IDENTITY()

	begin try

		-- check if input parameters are valid
		exec [global].CheckObjectID @ObjectSchema = N'layout', @ObjectTable = N'Monitor', @ObjectID = @MonitorID, @CheckIsNull = 1, @ProcedureLogID = @procedureLogID

		-- get necessary informations for resulting xml dataset
		select top 1
			@targetDailyID = d.ID,
			@shiftLogID = slso.ShiftLogID,
			@lineID = m.LineID
		from layout.Monitor m
			cross join dbo.ShiftLog sl
			inner join dbo.ShiftLogSignOff slso on m.LineID = slso.LineID and sl.ID = slso.ShiftLogID
			left join [target].Daily d on m.LineID = d.LineID and slso.ShiftLogID = d.ShiftLogID
		where m.ID = @MonitorID
			and d.Billboard = 1
			and slso.SignedOffOperatorID is NULL
		order by sl.DataStart

		-- if target is missing there is no plan nor actuals values, all values are 0
		if @targetDailyID is NULL
			exec [target].[AddTargetAutomatic] @LineID = @lineID, @ShiftLogID = @shiftLogID, @DailyID = @targetDailyID OUTPUT

		insert into @billboardLog(TargetHourlyID, HourStart, HourEnd, [Hour], [HourInterval], [Target], CumulativeTarget, ActualAchieved, CumulativeAchieved, Defects, Downtime, Comment, Escalated, SignedOffOperatorID, SignedOffOperatorBarcode)
		select TargetHourlyID, HourStart, HourEnd, [Hour], [HourInterval], [Target], CumulativeTarget, ActualAchieved, CumulativeAchieved, Defects, Downtime, Comment, Escalated, SignedOffOperatorID, SignedOffOperatorBarcode
		from vBillboardLog
		where TargetDailyID = @targetDailyID

		set @XML = (
			select
				CONVERT(nvarchar(10), sl.[Data], 20) 'date', sl.ShiftName 'shift',
				l.[Name] 'lineName', sl.LocationName 'locationName',
				CONVERT(decimal(6,2), ROUND((
					select CONVERT(decimal(10,2), MAX(CumulativeAchieved)) /
						CONVERT(decimal(10,2), case
							when MAX(HourEnd) < [global].[GetDate]() then 440
							when MIN(HourStart) = [global].[GetDate]() then 1
							else DATEDIFF(MINUTE, MIN([HourStart]), [global].[GetDate]()) / 12 * 11
						end)
					from @billboardLog
				), 2)) 'deliveryTime',
				(
					select MAX(ActualAchieved)
					from @billboardLog
				) 'maxHourProduction',
				(select slso.ID '@shiftLogSignOffID',
					(select	bl.TargetHourlyID '@id',
						case when bl.SignedOffOperatorID is not NULL then 'yes' end '@closed',
						case when fo.[Hour] is not NULL then 'yes' end '@firstOpen',
						bl.HourInterval 'hourInterval', bl.[Target] 'target', bl.CumulativeTarget 'cumulativeTarget',
						bl.ActualAchieved 'achieved', bl.CumulativeAchieved 'cumulativeAchieved', bl.Defects 'defects',
						bl.Downtime 'downtime', bl.Comment 'comment', bl.Escalated 'escalated', bl.SignedOffOperatorBarcode 'signoff'
					from @billboardLog bl
						left join (
							select MIN([Hour]) [Hour]
							from @billboardLog
							where SignedOffOperatorID is NULL
						) fo on bl.[Hour] = fo.[Hour]
					order by bl.[Hour]
					for xml path('hour'), type, elements XSINIL)
				for xml path('hours'), type)
			from layout.Line l
				cross join dbo.vShiftLog sl
				inner join dbo.ShiftLogSignOff slso on l.ID = slso.LineID and sl.ID = slso.ShiftLogID
			where l.ID = @lineID
				and sl.ID = @shiftLogID
			for xml path('billboard'), type)
		if @XML is NULL goto EmptyXML

		update [log].ProcedureLog
		set XMLParam = @xml
		where ID = @procedureLogID
	end try
	begin catch
		set @errorNumber = ERROR_NUMBER()
		set @errorMessage =  ERROR_MESSAGE()
		goto ErrorExit
	end catch
return(0)

EmptyXML:
	set @errorMessage = N'Empty XML dataset'
ErrorExit:
	declare @returnError int
	exec [global].TraceError @ErrorNumber = @errorNumber, @ErrorMessage = @errorMessage, @ProcedureLogID = @procedureLogID, @ReturnError = @returnError OUTPUT
	return(@returnError)
GO
PRINT N'Refreshing [dbo].[ftBillboardDowntime]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[ftBillboardDowntime]';


GO
PRINT N'Refreshing [target].[SetBillboardOnByIDList]...';


GO
EXECUTE sp_refreshsqlmodule N'[target].[SetBillboardOnByIDList]';


GO
PRINT N'Refreshing [users].[ForceLogoutIfTokensHaveExpired]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[ForceLogoutIfTokensHaveExpired]';


GO
PRINT N'Refreshing [users].[ClearExpiredTokens]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[ClearExpiredTokens]';


GO
PRINT N'Refreshing [users].[SaveRights]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[SaveRights]';


GO
PRINT N'Refreshing [dbo].[BillboardAutomaticSignOff]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[BillboardAutomaticSignOff]';


GO
PRINT N'Refreshing [dbo].[BillboardSaveComment]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[BillboardSaveComment]';


GO
PRINT N'Refreshing [dbo].[BillboardSaveEscalated]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[BillboardSaveEscalated]';


GO
PRINT N'Refreshing [dbo].[SaveBreaks]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[SaveBreaks]';


GO
PRINT N'Refreshing [layout].[GetProductionLines]...';


GO
EXECUTE sp_refreshsqlmodule N'[layout].[GetProductionLines]';


GO
PRINT N'Refreshing [target].[SaveTargetByDay]...';


GO
EXECUTE sp_refreshsqlmodule N'[target].[SaveTargetByDay]';


GO
PRINT N'Refreshing [target].[GetTargetByPartNumber]...';


GO
EXECUTE sp_refreshsqlmodule N'[target].[GetTargetByPartNumber]';


GO
PRINT N'Refreshing [users].[Logout]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[Logout]';


GO
PRINT N'Refreshing [users].[GetRights]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[GetRights]';


GO
PRINT N'Refreshing [report].[HistoricalShift]...';


GO
EXECUTE sp_refreshsqlmodule N'[report].[HistoricalShift]';


GO
PRINT N'Refreshing [dbo].[BillboardHourSignOff]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[BillboardHourSignOff]';


GO
PRINT N'Refreshing [dbo].[BillboardShiftSignOff]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[BillboardShiftSignOff]';


GO
PRINT N'Refreshing [dbo].[GetBreaks]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[GetBreaks]';


GO
PRINT N'Refreshing [target].[GetPlanningDataSets]...';


GO
EXECUTE sp_refreshsqlmodule N'[target].[GetPlanningDataSets]';


GO
PRINT N'Refreshing [target].[GetTargetByDay]...';


GO
EXECUTE sp_refreshsqlmodule N'[target].[GetTargetByDay]';


GO
PRINT N'Refreshing [users].[AddUser]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[AddUser]';


GO
PRINT N'Refreshing [users].[InsertOrUpdateToken]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[InsertOrUpdateToken]';


GO
PRINT N'Refreshing [target].[SetOnBillboard]...';


GO
EXECUTE sp_refreshsqlmodule N'[target].[SetOnBillboard]';


GO
PRINT N'Refreshing [users].[Login]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[Login]';


GO
PRINT N'Refreshing [users].[LoginOnWorkbench]...';


GO
EXECUTE sp_refreshsqlmodule N'[users].[LoginOnWorkbench]';


GO
PRINT N'Refreshing [dbo].[BillboardUpdateActuals]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[BillboardUpdateActuals]';


GO
PRINT N'Refreshing [import].[GetActualsLog]...';


GO
EXECUTE sp_refreshsqlmodule N'[import].[GetActualsLog]';


GO
PRINT N'Update complete.';


GO
